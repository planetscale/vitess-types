// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: vtctlservice/vtctlservice.proto

package vtctlserviceconnect

import (
	context "context"
	errors "errors"
	connect_go "github.com/bufbuild/connect-go"
	vtctldata "github.com/planetscale/vitess-types/gen/vitess/v15/vtctldata"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect_go.IsAtLeastVersion0_1_0

const (
	// VtctlName is the fully-qualified name of the Vtctl service.
	VtctlName = "vtctlservice.Vtctl"
	// VtctldName is the fully-qualified name of the Vtctld service.
	VtctldName = "vtctlservice.Vtctld"
)

// VtctlClient is a client for the vtctlservice.Vtctl service.
type VtctlClient interface {
	ExecuteVtctlCommand(context.Context, *connect_go.Request[vtctldata.ExecuteVtctlCommandRequest]) (*connect_go.ServerStreamForClient[vtctldata.ExecuteVtctlCommandResponse], error)
}

// NewVtctlClient constructs a client for the vtctlservice.Vtctl service. By default, it uses the
// Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewVtctlClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) VtctlClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &vtctlClient{
		executeVtctlCommand: connect_go.NewClient[vtctldata.ExecuteVtctlCommandRequest, vtctldata.ExecuteVtctlCommandResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctl/ExecuteVtctlCommand",
			opts...,
		),
	}
}

// vtctlClient implements VtctlClient.
type vtctlClient struct {
	executeVtctlCommand *connect_go.Client[vtctldata.ExecuteVtctlCommandRequest, vtctldata.ExecuteVtctlCommandResponse]
}

// ExecuteVtctlCommand calls vtctlservice.Vtctl.ExecuteVtctlCommand.
func (c *vtctlClient) ExecuteVtctlCommand(ctx context.Context, req *connect_go.Request[vtctldata.ExecuteVtctlCommandRequest]) (*connect_go.ServerStreamForClient[vtctldata.ExecuteVtctlCommandResponse], error) {
	return c.executeVtctlCommand.CallServerStream(ctx, req)
}

// VtctlHandler is an implementation of the vtctlservice.Vtctl service.
type VtctlHandler interface {
	ExecuteVtctlCommand(context.Context, *connect_go.Request[vtctldata.ExecuteVtctlCommandRequest], *connect_go.ServerStream[vtctldata.ExecuteVtctlCommandResponse]) error
}

// NewVtctlHandler builds an HTTP handler from the service implementation. It returns the path on
// which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewVtctlHandler(svc VtctlHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/vtctlservice.Vtctl/ExecuteVtctlCommand", connect_go.NewServerStreamHandler(
		"/vtctlservice.Vtctl/ExecuteVtctlCommand",
		svc.ExecuteVtctlCommand,
		opts...,
	))
	return "/vtctlservice.Vtctl/", mux
}

// UnimplementedVtctlHandler returns CodeUnimplemented from all methods.
type UnimplementedVtctlHandler struct{}

func (UnimplementedVtctlHandler) ExecuteVtctlCommand(context.Context, *connect_go.Request[vtctldata.ExecuteVtctlCommandRequest], *connect_go.ServerStream[vtctldata.ExecuteVtctlCommandResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctl.ExecuteVtctlCommand is not implemented"))
}

// VtctldClient is a client for the vtctlservice.Vtctld service.
type VtctldClient interface {
	// AddCellInfo registers a local topology service in a new cell by creating
	// the CellInfo with the provided parameters.
	AddCellInfo(context.Context, *connect_go.Request[vtctldata.AddCellInfoRequest]) (*connect_go.Response[vtctldata.AddCellInfoResponse], error)
	// AddCellsAlias defines a group of cells that can be referenced by a single
	// name (the alias).
	//
	// When routing query traffic, replica/rdonly traffic can be routed across
	// cells within the group (alias). Only primary traffic can be routed across
	// cells not in the same group (alias).
	AddCellsAlias(context.Context, *connect_go.Request[vtctldata.AddCellsAliasRequest]) (*connect_go.Response[vtctldata.AddCellsAliasResponse], error)
	// ApplyRoutingRules applies the VSchema routing rules.
	ApplyRoutingRules(context.Context, *connect_go.Request[vtctldata.ApplyRoutingRulesRequest]) (*connect_go.Response[vtctldata.ApplyRoutingRulesResponse], error)
	// ApplySchema applies a schema to a keyspace.
	ApplySchema(context.Context, *connect_go.Request[vtctldata.ApplySchemaRequest]) (*connect_go.Response[vtctldata.ApplySchemaResponse], error)
	// ApplyShardRoutingRules applies the VSchema shard routing rules.
	ApplyShardRoutingRules(context.Context, *connect_go.Request[vtctldata.ApplyShardRoutingRulesRequest]) (*connect_go.Response[vtctldata.ApplyShardRoutingRulesResponse], error)
	// ApplyVSchema applies a vschema to a keyspace.
	ApplyVSchema(context.Context, *connect_go.Request[vtctldata.ApplyVSchemaRequest]) (*connect_go.Response[vtctldata.ApplyVSchemaResponse], error)
	// Backup uses the BackupEngine and BackupStorage services on the specified
	// tablet to create and store a new backup.
	Backup(context.Context, *connect_go.Request[vtctldata.BackupRequest]) (*connect_go.ServerStreamForClient[vtctldata.BackupResponse], error)
	// BackupShard chooses a tablet in the shard and uses it to create a backup.
	BackupShard(context.Context, *connect_go.Request[vtctldata.BackupShardRequest]) (*connect_go.ServerStreamForClient[vtctldata.BackupResponse], error)
	// ChangeTabletType changes the db type for the specified tablet, if possible.
	// This is used primarily to arrange replicas, and it will not convert a
	// primary. For that, use InitShardPrimary.
	//
	// NOTE: This command automatically updates the serving graph.
	ChangeTabletType(context.Context, *connect_go.Request[vtctldata.ChangeTabletTypeRequest]) (*connect_go.Response[vtctldata.ChangeTabletTypeResponse], error)
	// CreateKeyspace creates the specified keyspace in the topology. For a
	// SNAPSHOT keyspace, the request must specify the name of a base keyspace,
	// as well as a snapshot time.
	CreateKeyspace(context.Context, *connect_go.Request[vtctldata.CreateKeyspaceRequest]) (*connect_go.Response[vtctldata.CreateKeyspaceResponse], error)
	// CreateShard creates the specified shard in the topology.
	CreateShard(context.Context, *connect_go.Request[vtctldata.CreateShardRequest]) (*connect_go.Response[vtctldata.CreateShardResponse], error)
	// DeleteCellInfo deletes the CellInfo for the provided cell. The cell cannot
	// be referenced by any Shard record in the topology.
	DeleteCellInfo(context.Context, *connect_go.Request[vtctldata.DeleteCellInfoRequest]) (*connect_go.Response[vtctldata.DeleteCellInfoResponse], error)
	// DeleteCellsAlias deletes the CellsAlias for the provided alias.
	DeleteCellsAlias(context.Context, *connect_go.Request[vtctldata.DeleteCellsAliasRequest]) (*connect_go.Response[vtctldata.DeleteCellsAliasResponse], error)
	// DeleteKeyspace deletes the specified keyspace from the topology. In
	// recursive mode, it also recursively deletes all shards in the keyspace.
	// Otherwise, the keyspace must be empty (have no shards), or DeleteKeyspace
	// returns an error.
	DeleteKeyspace(context.Context, *connect_go.Request[vtctldata.DeleteKeyspaceRequest]) (*connect_go.Response[vtctldata.DeleteKeyspaceResponse], error)
	// DeleteShards deletes the specified shards from the topology. In recursive
	// mode, it also deletes all tablets belonging to the shard. Otherwise, the
	// shard must be empty (have no tablets) or DeleteShards returns an error for
	// that shard.
	DeleteShards(context.Context, *connect_go.Request[vtctldata.DeleteShardsRequest]) (*connect_go.Response[vtctldata.DeleteShardsResponse], error)
	// DeleteSrvVSchema deletes the SrvVSchema object in the specified cell.
	DeleteSrvVSchema(context.Context, *connect_go.Request[vtctldata.DeleteSrvVSchemaRequest]) (*connect_go.Response[vtctldata.DeleteSrvVSchemaResponse], error)
	// DeleteTablets deletes one or more tablets from the topology.
	DeleteTablets(context.Context, *connect_go.Request[vtctldata.DeleteTabletsRequest]) (*connect_go.Response[vtctldata.DeleteTabletsResponse], error)
	// EmergencyReparentShard reparents the shard to the new primary. It assumes
	// the old primary is dead or otherwise not responding.
	EmergencyReparentShard(context.Context, *connect_go.Request[vtctldata.EmergencyReparentShardRequest]) (*connect_go.Response[vtctldata.EmergencyReparentShardResponse], error)
	// ExecuteFetchAsApp executes a SQL query on the remote tablet as the App user.
	ExecuteFetchAsApp(context.Context, *connect_go.Request[vtctldata.ExecuteFetchAsAppRequest]) (*connect_go.Response[vtctldata.ExecuteFetchAsAppResponse], error)
	// ExecuteFetchAsDBA executes a SQL query on the remote tablet as the DBA user.
	ExecuteFetchAsDBA(context.Context, *connect_go.Request[vtctldata.ExecuteFetchAsDBARequest]) (*connect_go.Response[vtctldata.ExecuteFetchAsDBAResponse], error)
	// ExecuteHook runs the hook on the tablet.
	ExecuteHook(context.Context, *connect_go.Request[vtctldata.ExecuteHookRequest]) (*connect_go.Response[vtctldata.ExecuteHookResponse], error)
	// FindAllShardsInKeyspace returns a map of shard names to shard references
	// for a given keyspace.
	FindAllShardsInKeyspace(context.Context, *connect_go.Request[vtctldata.FindAllShardsInKeyspaceRequest]) (*connect_go.Response[vtctldata.FindAllShardsInKeyspaceResponse], error)
	// GetBackups returns all the backups for a shard.
	GetBackups(context.Context, *connect_go.Request[vtctldata.GetBackupsRequest]) (*connect_go.Response[vtctldata.GetBackupsResponse], error)
	// GetCellInfo returns the information for a cell.
	GetCellInfo(context.Context, *connect_go.Request[vtctldata.GetCellInfoRequest]) (*connect_go.Response[vtctldata.GetCellInfoResponse], error)
	// GetCellInfoNames returns all the cells for which we have a CellInfo object,
	// meaning we have a topology service registered.
	GetCellInfoNames(context.Context, *connect_go.Request[vtctldata.GetCellInfoNamesRequest]) (*connect_go.Response[vtctldata.GetCellInfoNamesResponse], error)
	// GetCellsAliases returns a mapping of cell alias to cells identified by that
	// alias.
	GetCellsAliases(context.Context, *connect_go.Request[vtctldata.GetCellsAliasesRequest]) (*connect_go.Response[vtctldata.GetCellsAliasesResponse], error)
	// GetFullStatus returns the full status of MySQL including the replication information, semi-sync information, GTID information among others
	GetFullStatus(context.Context, *connect_go.Request[vtctldata.GetFullStatusRequest]) (*connect_go.Response[vtctldata.GetFullStatusResponse], error)
	// GetKeyspace reads the given keyspace from the topo and returns it.
	GetKeyspace(context.Context, *connect_go.Request[vtctldata.GetKeyspaceRequest]) (*connect_go.Response[vtctldata.GetKeyspaceResponse], error)
	// GetKeyspaces returns the keyspace struct of all keyspaces in the topo.
	GetKeyspaces(context.Context, *connect_go.Request[vtctldata.GetKeyspacesRequest]) (*connect_go.Response[vtctldata.GetKeyspacesResponse], error)
	// GetPermissions returns the permissions set on the remote tablet.
	GetPermissions(context.Context, *connect_go.Request[vtctldata.GetPermissionsRequest]) (*connect_go.Response[vtctldata.GetPermissionsResponse], error)
	// GetRoutingRules returns the VSchema routing rules.
	GetRoutingRules(context.Context, *connect_go.Request[vtctldata.GetRoutingRulesRequest]) (*connect_go.Response[vtctldata.GetRoutingRulesResponse], error)
	// GetSchema returns the schema for a tablet, or just the schema for the
	// specified tables in that tablet.
	GetSchema(context.Context, *connect_go.Request[vtctldata.GetSchemaRequest]) (*connect_go.Response[vtctldata.GetSchemaResponse], error)
	// GetShard returns information about a shard in the topology.
	GetShard(context.Context, *connect_go.Request[vtctldata.GetShardRequest]) (*connect_go.Response[vtctldata.GetShardResponse], error)
	// GetShardRoutingRules returns the VSchema shard routing rules.
	GetShardRoutingRules(context.Context, *connect_go.Request[vtctldata.GetShardRoutingRulesRequest]) (*connect_go.Response[vtctldata.GetShardRoutingRulesResponse], error)
	// GetSrvKeyspaceNames returns a mapping of cell name to the keyspaces served
	// in that cell.
	GetSrvKeyspaceNames(context.Context, *connect_go.Request[vtctldata.GetSrvKeyspaceNamesRequest]) (*connect_go.Response[vtctldata.GetSrvKeyspaceNamesResponse], error)
	// GetSrvKeyspaces returns the SrvKeyspaces for a keyspace in one or more
	// cells.
	GetSrvKeyspaces(context.Context, *connect_go.Request[vtctldata.GetSrvKeyspacesRequest]) (*connect_go.Response[vtctldata.GetSrvKeyspacesResponse], error)
	// GetSrvVSchema returns the SrvVSchema for a cell.
	GetSrvVSchema(context.Context, *connect_go.Request[vtctldata.GetSrvVSchemaRequest]) (*connect_go.Response[vtctldata.GetSrvVSchemaResponse], error)
	// GetSrvVSchemas returns a mapping from cell name to SrvVSchema for all cells,
	// optionally filtered by cell name.
	GetSrvVSchemas(context.Context, *connect_go.Request[vtctldata.GetSrvVSchemasRequest]) (*connect_go.Response[vtctldata.GetSrvVSchemasResponse], error)
	// GetTablet returns information about a tablet.
	GetTablet(context.Context, *connect_go.Request[vtctldata.GetTabletRequest]) (*connect_go.Response[vtctldata.GetTabletResponse], error)
	// GetTablets returns tablets, optionally filtered by keyspace and shard.
	GetTablets(context.Context, *connect_go.Request[vtctldata.GetTabletsRequest]) (*connect_go.Response[vtctldata.GetTabletsResponse], error)
	// GetVersion returns the version of a tablet from its debug vars.
	GetVersion(context.Context, *connect_go.Request[vtctldata.GetVersionRequest]) (*connect_go.Response[vtctldata.GetVersionResponse], error)
	// GetVSchema returns the vschema for a keyspace.
	GetVSchema(context.Context, *connect_go.Request[vtctldata.GetVSchemaRequest]) (*connect_go.Response[vtctldata.GetVSchemaResponse], error)
	// GetWorkflows returns a list of workflows for the given keyspace.
	GetWorkflows(context.Context, *connect_go.Request[vtctldata.GetWorkflowsRequest]) (*connect_go.Response[vtctldata.GetWorkflowsResponse], error)
	// InitShardPrimary sets the initial primary for a shard. Will make all other
	// tablets in the shard replicas of the provided primary.
	//
	// WARNING: This could cause data loss on an already replicating shard.
	// PlannedReparentShard or EmergencyReparentShard should be used in those
	// cases instead.
	InitShardPrimary(context.Context, *connect_go.Request[vtctldata.InitShardPrimaryRequest]) (*connect_go.Response[vtctldata.InitShardPrimaryResponse], error)
	// PingTablet checks that the specified tablet is awake and responding to RPCs.
	// This command can be blocked by other in-flight operations.
	PingTablet(context.Context, *connect_go.Request[vtctldata.PingTabletRequest]) (*connect_go.Response[vtctldata.PingTabletResponse], error)
	// PlannedReparentShard reparents the shard to the new primary, or away from
	// an old primary. Both the old and new primaries need to be reachable and
	// running.
	//
	// **NOTE**: The vtctld will not consider any replicas outside the cell the
	// current shard primary is in for promotion unless NewPrimary is explicitly
	// provided in the request.
	PlannedReparentShard(context.Context, *connect_go.Request[vtctldata.PlannedReparentShardRequest]) (*connect_go.Response[vtctldata.PlannedReparentShardResponse], error)
	// RebuildKeyspaceGraph rebuilds the serving data for a keyspace.
	//
	// This may trigger an update to all connected clients.
	RebuildKeyspaceGraph(context.Context, *connect_go.Request[vtctldata.RebuildKeyspaceGraphRequest]) (*connect_go.Response[vtctldata.RebuildKeyspaceGraphResponse], error)
	// RebuildVSchemaGraph rebuilds the per-cell SrvVSchema from the global
	// VSchema objects in the provided cells (or all cells in the topo none
	// provided).
	RebuildVSchemaGraph(context.Context, *connect_go.Request[vtctldata.RebuildVSchemaGraphRequest]) (*connect_go.Response[vtctldata.RebuildVSchemaGraphResponse], error)
	// RefreshState reloads the tablet record on the specified tablet.
	RefreshState(context.Context, *connect_go.Request[vtctldata.RefreshStateRequest]) (*connect_go.Response[vtctldata.RefreshStateResponse], error)
	// RefreshStateByShard calls RefreshState on all the tablets in the given shard.
	RefreshStateByShard(context.Context, *connect_go.Request[vtctldata.RefreshStateByShardRequest]) (*connect_go.Response[vtctldata.RefreshStateByShardResponse], error)
	// ReloadSchema instructs the remote tablet to reload its schema.
	ReloadSchema(context.Context, *connect_go.Request[vtctldata.ReloadSchemaRequest]) (*connect_go.Response[vtctldata.ReloadSchemaResponse], error)
	// ReloadSchemaKeyspace reloads the schema on all tablets in a keyspace.
	ReloadSchemaKeyspace(context.Context, *connect_go.Request[vtctldata.ReloadSchemaKeyspaceRequest]) (*connect_go.Response[vtctldata.ReloadSchemaKeyspaceResponse], error)
	// ReloadSchemaShard reloads the schema on all tablets in a shard.
	//
	// In general, we don't always expect all replicas to be ready to reload, and
	// the periodic schema reload makes them self-healing anyway. So, we do this
	// on a best-effort basis, and log warnings for any tablets that fail to
	// reload within the context deadline.
	ReloadSchemaShard(context.Context, *connect_go.Request[vtctldata.ReloadSchemaShardRequest]) (*connect_go.Response[vtctldata.ReloadSchemaShardResponse], error)
	// RemoveBackup removes a backup from the BackupStorage used by vtctld.
	RemoveBackup(context.Context, *connect_go.Request[vtctldata.RemoveBackupRequest]) (*connect_go.Response[vtctldata.RemoveBackupResponse], error)
	// RemoveKeyspaceCell removes the specified cell from the Cells list for all
	// shards in the specified keyspace (by calling RemoveShardCell on every
	// shard). It also removes the SrvKeyspace for that keyspace in that cell.
	RemoveKeyspaceCell(context.Context, *connect_go.Request[vtctldata.RemoveKeyspaceCellRequest]) (*connect_go.Response[vtctldata.RemoveKeyspaceCellResponse], error)
	// RemoveShardCell removes the specified cell from the specified shard's Cells
	// list.
	RemoveShardCell(context.Context, *connect_go.Request[vtctldata.RemoveShardCellRequest]) (*connect_go.Response[vtctldata.RemoveShardCellResponse], error)
	// ReparentTablet reparents a tablet to the current primary in the shard. This
	// only works if the current replica position matches the last known reparent
	// action.
	ReparentTablet(context.Context, *connect_go.Request[vtctldata.ReparentTabletRequest]) (*connect_go.Response[vtctldata.ReparentTabletResponse], error)
	// RestoreFromBackup stops mysqld for the given tablet and restores a backup.
	RestoreFromBackup(context.Context, *connect_go.Request[vtctldata.RestoreFromBackupRequest]) (*connect_go.ServerStreamForClient[vtctldata.RestoreFromBackupResponse], error)
	// RunHealthCheck runs a healthcheck on the remote tablet.
	RunHealthCheck(context.Context, *connect_go.Request[vtctldata.RunHealthCheckRequest]) (*connect_go.Response[vtctldata.RunHealthCheckResponse], error)
	// SetKeyspaceDurabilityPolicy updates the DurabilityPolicy for a keyspace.
	SetKeyspaceDurabilityPolicy(context.Context, *connect_go.Request[vtctldata.SetKeyspaceDurabilityPolicyRequest]) (*connect_go.Response[vtctldata.SetKeyspaceDurabilityPolicyResponse], error)
	// SetShardIsPrimaryServing adds or removes a shard from serving.
	//
	// This is meant as an emergency function. It does not rebuild any serving
	// graph (i.e. it does not run RebuildKeyspaceGraph).
	SetShardIsPrimaryServing(context.Context, *connect_go.Request[vtctldata.SetShardIsPrimaryServingRequest]) (*connect_go.Response[vtctldata.SetShardIsPrimaryServingResponse], error)
	// SetShardTabletControl updates the TabletControl topo record for a shard and
	// tablet type.
	//
	// This should only be used for an emergency fix, or after a finished
	// Reshard. See the documentation on SetShardTabletControlRequest for more
	// information about the different update modes.
	SetShardTabletControl(context.Context, *connect_go.Request[vtctldata.SetShardTabletControlRequest]) (*connect_go.Response[vtctldata.SetShardTabletControlResponse], error)
	// SetWritable sets a tablet as read-write (writable=true) or read-only (writable=false).
	SetWritable(context.Context, *connect_go.Request[vtctldata.SetWritableRequest]) (*connect_go.Response[vtctldata.SetWritableResponse], error)
	// ShardReplicationAdd adds an entry to a topodata.ShardReplication object.
	//
	// It is a low-level function and should generally not be called.
	ShardReplicationAdd(context.Context, *connect_go.Request[vtctldata.ShardReplicationAddRequest]) (*connect_go.Response[vtctldata.ShardReplicationAddResponse], error)
	// ShardReplicationFix walks the replication graph for a shard in a cell and
	// attempts to fix the first problem encountered, returning information about
	// the problem fixed, if any.
	ShardReplicationFix(context.Context, *connect_go.Request[vtctldata.ShardReplicationFixRequest]) (*connect_go.Response[vtctldata.ShardReplicationFixResponse], error)
	// ShardReplicationPositions returns the replication position of each tablet
	// in a shard. This RPC makes a best-effort to return partial results. For
	// example, if one tablet in the shard graph is unreachable, then
	// ShardReplicationPositions will return non-error, and include valid results
	// for the reachable tablets.
	ShardReplicationPositions(context.Context, *connect_go.Request[vtctldata.ShardReplicationPositionsRequest]) (*connect_go.Response[vtctldata.ShardReplicationPositionsResponse], error)
	// ShardReplicationRemove removes an entry from a topodata.ShardReplication
	// object.
	//
	// It is a low-level function and should generally not be called.
	ShardReplicationRemove(context.Context, *connect_go.Request[vtctldata.ShardReplicationRemoveRequest]) (*connect_go.Response[vtctldata.ShardReplicationRemoveResponse], error)
	// SleepTablet blocks the aciton queue on the specified tablet for the
	// specified duration.
	//
	// This is typically used for testing.
	SleepTablet(context.Context, *connect_go.Request[vtctldata.SleepTabletRequest]) (*connect_go.Response[vtctldata.SleepTabletResponse], error)
	// SourceShardAdd adds the SourceShard record with the provided index. This
	// should be used only as an emergency function.
	//
	// It does not call RefreshState for the shard primary.
	SourceShardAdd(context.Context, *connect_go.Request[vtctldata.SourceShardAddRequest]) (*connect_go.Response[vtctldata.SourceShardAddResponse], error)
	// SourceShardDelete deletes the SourceShard record with the provided index.
	// This should be used only as an emergency cleanup function.
	//
	// It does not call RefreshState for the shard primary.
	SourceShardDelete(context.Context, *connect_go.Request[vtctldata.SourceShardDeleteRequest]) (*connect_go.Response[vtctldata.SourceShardDeleteResponse], error)
	// StartReplication starts replication on the specified tablet.
	StartReplication(context.Context, *connect_go.Request[vtctldata.StartReplicationRequest]) (*connect_go.Response[vtctldata.StartReplicationResponse], error)
	// StopReplication stops replication on the specified tablet.
	StopReplication(context.Context, *connect_go.Request[vtctldata.StopReplicationRequest]) (*connect_go.Response[vtctldata.StopReplicationResponse], error)
	// TabletExternallyReparented changes metadata in the topology server to
	// acknowledge a shard primary change performed by an external tool (e.g.
	// orchestrator).
	//
	// See the Reparenting guide for more information:
	// https://vitess.io/docs/user-guides/configuration-advanced/reparenting/#external-reparenting.
	TabletExternallyReparented(context.Context, *connect_go.Request[vtctldata.TabletExternallyReparentedRequest]) (*connect_go.Response[vtctldata.TabletExternallyReparentedResponse], error)
	// UpdateCellInfo updates the content of a CellInfo with the provided
	// parameters. Empty values are ignored. If the cell does not exist, the
	// CellInfo will be created.
	UpdateCellInfo(context.Context, *connect_go.Request[vtctldata.UpdateCellInfoRequest]) (*connect_go.Response[vtctldata.UpdateCellInfoResponse], error)
	// UpdateCellsAlias updates the content of a CellsAlias with the provided
	// parameters. Empty values are ignored. If the alias does not exist, the
	// CellsAlias will be created.
	UpdateCellsAlias(context.Context, *connect_go.Request[vtctldata.UpdateCellsAliasRequest]) (*connect_go.Response[vtctldata.UpdateCellsAliasResponse], error)
	// Validate validates that all nodes from the global replication graph are
	// reachable, and that all tablets in discoverable cells are consistent.
	Validate(context.Context, *connect_go.Request[vtctldata.ValidateRequest]) (*connect_go.Response[vtctldata.ValidateResponse], error)
	// ValidateKeyspace validates that all nodes reachable from the specified
	// keyspace are consistent.
	ValidateKeyspace(context.Context, *connect_go.Request[vtctldata.ValidateKeyspaceRequest]) (*connect_go.Response[vtctldata.ValidateKeyspaceResponse], error)
	// ValidateSchemaKeyspace validates that the schema on the primary tablet for shard 0 matches the schema on all of the other tablets in the keyspace.
	ValidateSchemaKeyspace(context.Context, *connect_go.Request[vtctldata.ValidateSchemaKeyspaceRequest]) (*connect_go.Response[vtctldata.ValidateSchemaKeyspaceResponse], error)
	// ValidateShard validates that all nodes reachable from the specified shard
	// are consistent.
	ValidateShard(context.Context, *connect_go.Request[vtctldata.ValidateShardRequest]) (*connect_go.Response[vtctldata.ValidateShardResponse], error)
	// ValidateVersionKeyspace validates that the version on the primary of shard 0 matches all of the other tablets in the keyspace.
	ValidateVersionKeyspace(context.Context, *connect_go.Request[vtctldata.ValidateVersionKeyspaceRequest]) (*connect_go.Response[vtctldata.ValidateVersionKeyspaceResponse], error)
	// ValidateVSchema compares the schema of each primary tablet in "keyspace/shards..." to the vschema and errs if there are differences.
	ValidateVSchema(context.Context, *connect_go.Request[vtctldata.ValidateVSchemaRequest]) (*connect_go.Response[vtctldata.ValidateVSchemaResponse], error)
}

// NewVtctldClient constructs a client for the vtctlservice.Vtctld service. By default, it uses the
// Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewVtctldClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) VtctldClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &vtctldClient{
		addCellInfo: connect_go.NewClient[vtctldata.AddCellInfoRequest, vtctldata.AddCellInfoResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/AddCellInfo",
			opts...,
		),
		addCellsAlias: connect_go.NewClient[vtctldata.AddCellsAliasRequest, vtctldata.AddCellsAliasResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/AddCellsAlias",
			opts...,
		),
		applyRoutingRules: connect_go.NewClient[vtctldata.ApplyRoutingRulesRequest, vtctldata.ApplyRoutingRulesResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ApplyRoutingRules",
			opts...,
		),
		applySchema: connect_go.NewClient[vtctldata.ApplySchemaRequest, vtctldata.ApplySchemaResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ApplySchema",
			opts...,
		),
		applyShardRoutingRules: connect_go.NewClient[vtctldata.ApplyShardRoutingRulesRequest, vtctldata.ApplyShardRoutingRulesResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ApplyShardRoutingRules",
			opts...,
		),
		applyVSchema: connect_go.NewClient[vtctldata.ApplyVSchemaRequest, vtctldata.ApplyVSchemaResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ApplyVSchema",
			opts...,
		),
		backup: connect_go.NewClient[vtctldata.BackupRequest, vtctldata.BackupResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/Backup",
			opts...,
		),
		backupShard: connect_go.NewClient[vtctldata.BackupShardRequest, vtctldata.BackupResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/BackupShard",
			opts...,
		),
		changeTabletType: connect_go.NewClient[vtctldata.ChangeTabletTypeRequest, vtctldata.ChangeTabletTypeResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ChangeTabletType",
			opts...,
		),
		createKeyspace: connect_go.NewClient[vtctldata.CreateKeyspaceRequest, vtctldata.CreateKeyspaceResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/CreateKeyspace",
			opts...,
		),
		createShard: connect_go.NewClient[vtctldata.CreateShardRequest, vtctldata.CreateShardResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/CreateShard",
			opts...,
		),
		deleteCellInfo: connect_go.NewClient[vtctldata.DeleteCellInfoRequest, vtctldata.DeleteCellInfoResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/DeleteCellInfo",
			opts...,
		),
		deleteCellsAlias: connect_go.NewClient[vtctldata.DeleteCellsAliasRequest, vtctldata.DeleteCellsAliasResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/DeleteCellsAlias",
			opts...,
		),
		deleteKeyspace: connect_go.NewClient[vtctldata.DeleteKeyspaceRequest, vtctldata.DeleteKeyspaceResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/DeleteKeyspace",
			opts...,
		),
		deleteShards: connect_go.NewClient[vtctldata.DeleteShardsRequest, vtctldata.DeleteShardsResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/DeleteShards",
			opts...,
		),
		deleteSrvVSchema: connect_go.NewClient[vtctldata.DeleteSrvVSchemaRequest, vtctldata.DeleteSrvVSchemaResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/DeleteSrvVSchema",
			opts...,
		),
		deleteTablets: connect_go.NewClient[vtctldata.DeleteTabletsRequest, vtctldata.DeleteTabletsResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/DeleteTablets",
			opts...,
		),
		emergencyReparentShard: connect_go.NewClient[vtctldata.EmergencyReparentShardRequest, vtctldata.EmergencyReparentShardResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/EmergencyReparentShard",
			opts...,
		),
		executeFetchAsApp: connect_go.NewClient[vtctldata.ExecuteFetchAsAppRequest, vtctldata.ExecuteFetchAsAppResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ExecuteFetchAsApp",
			opts...,
		),
		executeFetchAsDBA: connect_go.NewClient[vtctldata.ExecuteFetchAsDBARequest, vtctldata.ExecuteFetchAsDBAResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ExecuteFetchAsDBA",
			opts...,
		),
		executeHook: connect_go.NewClient[vtctldata.ExecuteHookRequest, vtctldata.ExecuteHookResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ExecuteHook",
			opts...,
		),
		findAllShardsInKeyspace: connect_go.NewClient[vtctldata.FindAllShardsInKeyspaceRequest, vtctldata.FindAllShardsInKeyspaceResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/FindAllShardsInKeyspace",
			opts...,
		),
		getBackups: connect_go.NewClient[vtctldata.GetBackupsRequest, vtctldata.GetBackupsResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetBackups",
			opts...,
		),
		getCellInfo: connect_go.NewClient[vtctldata.GetCellInfoRequest, vtctldata.GetCellInfoResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetCellInfo",
			opts...,
		),
		getCellInfoNames: connect_go.NewClient[vtctldata.GetCellInfoNamesRequest, vtctldata.GetCellInfoNamesResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetCellInfoNames",
			opts...,
		),
		getCellsAliases: connect_go.NewClient[vtctldata.GetCellsAliasesRequest, vtctldata.GetCellsAliasesResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetCellsAliases",
			opts...,
		),
		getFullStatus: connect_go.NewClient[vtctldata.GetFullStatusRequest, vtctldata.GetFullStatusResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetFullStatus",
			opts...,
		),
		getKeyspace: connect_go.NewClient[vtctldata.GetKeyspaceRequest, vtctldata.GetKeyspaceResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetKeyspace",
			opts...,
		),
		getKeyspaces: connect_go.NewClient[vtctldata.GetKeyspacesRequest, vtctldata.GetKeyspacesResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetKeyspaces",
			opts...,
		),
		getPermissions: connect_go.NewClient[vtctldata.GetPermissionsRequest, vtctldata.GetPermissionsResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetPermissions",
			opts...,
		),
		getRoutingRules: connect_go.NewClient[vtctldata.GetRoutingRulesRequest, vtctldata.GetRoutingRulesResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetRoutingRules",
			opts...,
		),
		getSchema: connect_go.NewClient[vtctldata.GetSchemaRequest, vtctldata.GetSchemaResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetSchema",
			opts...,
		),
		getShard: connect_go.NewClient[vtctldata.GetShardRequest, vtctldata.GetShardResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetShard",
			opts...,
		),
		getShardRoutingRules: connect_go.NewClient[vtctldata.GetShardRoutingRulesRequest, vtctldata.GetShardRoutingRulesResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetShardRoutingRules",
			opts...,
		),
		getSrvKeyspaceNames: connect_go.NewClient[vtctldata.GetSrvKeyspaceNamesRequest, vtctldata.GetSrvKeyspaceNamesResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetSrvKeyspaceNames",
			opts...,
		),
		getSrvKeyspaces: connect_go.NewClient[vtctldata.GetSrvKeyspacesRequest, vtctldata.GetSrvKeyspacesResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetSrvKeyspaces",
			opts...,
		),
		getSrvVSchema: connect_go.NewClient[vtctldata.GetSrvVSchemaRequest, vtctldata.GetSrvVSchemaResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetSrvVSchema",
			opts...,
		),
		getSrvVSchemas: connect_go.NewClient[vtctldata.GetSrvVSchemasRequest, vtctldata.GetSrvVSchemasResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetSrvVSchemas",
			opts...,
		),
		getTablet: connect_go.NewClient[vtctldata.GetTabletRequest, vtctldata.GetTabletResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetTablet",
			opts...,
		),
		getTablets: connect_go.NewClient[vtctldata.GetTabletsRequest, vtctldata.GetTabletsResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetTablets",
			opts...,
		),
		getVersion: connect_go.NewClient[vtctldata.GetVersionRequest, vtctldata.GetVersionResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetVersion",
			opts...,
		),
		getVSchema: connect_go.NewClient[vtctldata.GetVSchemaRequest, vtctldata.GetVSchemaResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetVSchema",
			opts...,
		),
		getWorkflows: connect_go.NewClient[vtctldata.GetWorkflowsRequest, vtctldata.GetWorkflowsResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/GetWorkflows",
			opts...,
		),
		initShardPrimary: connect_go.NewClient[vtctldata.InitShardPrimaryRequest, vtctldata.InitShardPrimaryResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/InitShardPrimary",
			opts...,
		),
		pingTablet: connect_go.NewClient[vtctldata.PingTabletRequest, vtctldata.PingTabletResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/PingTablet",
			opts...,
		),
		plannedReparentShard: connect_go.NewClient[vtctldata.PlannedReparentShardRequest, vtctldata.PlannedReparentShardResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/PlannedReparentShard",
			opts...,
		),
		rebuildKeyspaceGraph: connect_go.NewClient[vtctldata.RebuildKeyspaceGraphRequest, vtctldata.RebuildKeyspaceGraphResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/RebuildKeyspaceGraph",
			opts...,
		),
		rebuildVSchemaGraph: connect_go.NewClient[vtctldata.RebuildVSchemaGraphRequest, vtctldata.RebuildVSchemaGraphResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/RebuildVSchemaGraph",
			opts...,
		),
		refreshState: connect_go.NewClient[vtctldata.RefreshStateRequest, vtctldata.RefreshStateResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/RefreshState",
			opts...,
		),
		refreshStateByShard: connect_go.NewClient[vtctldata.RefreshStateByShardRequest, vtctldata.RefreshStateByShardResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/RefreshStateByShard",
			opts...,
		),
		reloadSchema: connect_go.NewClient[vtctldata.ReloadSchemaRequest, vtctldata.ReloadSchemaResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ReloadSchema",
			opts...,
		),
		reloadSchemaKeyspace: connect_go.NewClient[vtctldata.ReloadSchemaKeyspaceRequest, vtctldata.ReloadSchemaKeyspaceResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ReloadSchemaKeyspace",
			opts...,
		),
		reloadSchemaShard: connect_go.NewClient[vtctldata.ReloadSchemaShardRequest, vtctldata.ReloadSchemaShardResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ReloadSchemaShard",
			opts...,
		),
		removeBackup: connect_go.NewClient[vtctldata.RemoveBackupRequest, vtctldata.RemoveBackupResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/RemoveBackup",
			opts...,
		),
		removeKeyspaceCell: connect_go.NewClient[vtctldata.RemoveKeyspaceCellRequest, vtctldata.RemoveKeyspaceCellResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/RemoveKeyspaceCell",
			opts...,
		),
		removeShardCell: connect_go.NewClient[vtctldata.RemoveShardCellRequest, vtctldata.RemoveShardCellResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/RemoveShardCell",
			opts...,
		),
		reparentTablet: connect_go.NewClient[vtctldata.ReparentTabletRequest, vtctldata.ReparentTabletResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ReparentTablet",
			opts...,
		),
		restoreFromBackup: connect_go.NewClient[vtctldata.RestoreFromBackupRequest, vtctldata.RestoreFromBackupResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/RestoreFromBackup",
			opts...,
		),
		runHealthCheck: connect_go.NewClient[vtctldata.RunHealthCheckRequest, vtctldata.RunHealthCheckResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/RunHealthCheck",
			opts...,
		),
		setKeyspaceDurabilityPolicy: connect_go.NewClient[vtctldata.SetKeyspaceDurabilityPolicyRequest, vtctldata.SetKeyspaceDurabilityPolicyResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/SetKeyspaceDurabilityPolicy",
			opts...,
		),
		setShardIsPrimaryServing: connect_go.NewClient[vtctldata.SetShardIsPrimaryServingRequest, vtctldata.SetShardIsPrimaryServingResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/SetShardIsPrimaryServing",
			opts...,
		),
		setShardTabletControl: connect_go.NewClient[vtctldata.SetShardTabletControlRequest, vtctldata.SetShardTabletControlResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/SetShardTabletControl",
			opts...,
		),
		setWritable: connect_go.NewClient[vtctldata.SetWritableRequest, vtctldata.SetWritableResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/SetWritable",
			opts...,
		),
		shardReplicationAdd: connect_go.NewClient[vtctldata.ShardReplicationAddRequest, vtctldata.ShardReplicationAddResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ShardReplicationAdd",
			opts...,
		),
		shardReplicationFix: connect_go.NewClient[vtctldata.ShardReplicationFixRequest, vtctldata.ShardReplicationFixResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ShardReplicationFix",
			opts...,
		),
		shardReplicationPositions: connect_go.NewClient[vtctldata.ShardReplicationPositionsRequest, vtctldata.ShardReplicationPositionsResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ShardReplicationPositions",
			opts...,
		),
		shardReplicationRemove: connect_go.NewClient[vtctldata.ShardReplicationRemoveRequest, vtctldata.ShardReplicationRemoveResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ShardReplicationRemove",
			opts...,
		),
		sleepTablet: connect_go.NewClient[vtctldata.SleepTabletRequest, vtctldata.SleepTabletResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/SleepTablet",
			opts...,
		),
		sourceShardAdd: connect_go.NewClient[vtctldata.SourceShardAddRequest, vtctldata.SourceShardAddResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/SourceShardAdd",
			opts...,
		),
		sourceShardDelete: connect_go.NewClient[vtctldata.SourceShardDeleteRequest, vtctldata.SourceShardDeleteResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/SourceShardDelete",
			opts...,
		),
		startReplication: connect_go.NewClient[vtctldata.StartReplicationRequest, vtctldata.StartReplicationResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/StartReplication",
			opts...,
		),
		stopReplication: connect_go.NewClient[vtctldata.StopReplicationRequest, vtctldata.StopReplicationResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/StopReplication",
			opts...,
		),
		tabletExternallyReparented: connect_go.NewClient[vtctldata.TabletExternallyReparentedRequest, vtctldata.TabletExternallyReparentedResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/TabletExternallyReparented",
			opts...,
		),
		updateCellInfo: connect_go.NewClient[vtctldata.UpdateCellInfoRequest, vtctldata.UpdateCellInfoResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/UpdateCellInfo",
			opts...,
		),
		updateCellsAlias: connect_go.NewClient[vtctldata.UpdateCellsAliasRequest, vtctldata.UpdateCellsAliasResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/UpdateCellsAlias",
			opts...,
		),
		validate: connect_go.NewClient[vtctldata.ValidateRequest, vtctldata.ValidateResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/Validate",
			opts...,
		),
		validateKeyspace: connect_go.NewClient[vtctldata.ValidateKeyspaceRequest, vtctldata.ValidateKeyspaceResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ValidateKeyspace",
			opts...,
		),
		validateSchemaKeyspace: connect_go.NewClient[vtctldata.ValidateSchemaKeyspaceRequest, vtctldata.ValidateSchemaKeyspaceResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ValidateSchemaKeyspace",
			opts...,
		),
		validateShard: connect_go.NewClient[vtctldata.ValidateShardRequest, vtctldata.ValidateShardResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ValidateShard",
			opts...,
		),
		validateVersionKeyspace: connect_go.NewClient[vtctldata.ValidateVersionKeyspaceRequest, vtctldata.ValidateVersionKeyspaceResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ValidateVersionKeyspace",
			opts...,
		),
		validateVSchema: connect_go.NewClient[vtctldata.ValidateVSchemaRequest, vtctldata.ValidateVSchemaResponse](
			httpClient,
			baseURL+"/vtctlservice.Vtctld/ValidateVSchema",
			opts...,
		),
	}
}

// vtctldClient implements VtctldClient.
type vtctldClient struct {
	addCellInfo                 *connect_go.Client[vtctldata.AddCellInfoRequest, vtctldata.AddCellInfoResponse]
	addCellsAlias               *connect_go.Client[vtctldata.AddCellsAliasRequest, vtctldata.AddCellsAliasResponse]
	applyRoutingRules           *connect_go.Client[vtctldata.ApplyRoutingRulesRequest, vtctldata.ApplyRoutingRulesResponse]
	applySchema                 *connect_go.Client[vtctldata.ApplySchemaRequest, vtctldata.ApplySchemaResponse]
	applyShardRoutingRules      *connect_go.Client[vtctldata.ApplyShardRoutingRulesRequest, vtctldata.ApplyShardRoutingRulesResponse]
	applyVSchema                *connect_go.Client[vtctldata.ApplyVSchemaRequest, vtctldata.ApplyVSchemaResponse]
	backup                      *connect_go.Client[vtctldata.BackupRequest, vtctldata.BackupResponse]
	backupShard                 *connect_go.Client[vtctldata.BackupShardRequest, vtctldata.BackupResponse]
	changeTabletType            *connect_go.Client[vtctldata.ChangeTabletTypeRequest, vtctldata.ChangeTabletTypeResponse]
	createKeyspace              *connect_go.Client[vtctldata.CreateKeyspaceRequest, vtctldata.CreateKeyspaceResponse]
	createShard                 *connect_go.Client[vtctldata.CreateShardRequest, vtctldata.CreateShardResponse]
	deleteCellInfo              *connect_go.Client[vtctldata.DeleteCellInfoRequest, vtctldata.DeleteCellInfoResponse]
	deleteCellsAlias            *connect_go.Client[vtctldata.DeleteCellsAliasRequest, vtctldata.DeleteCellsAliasResponse]
	deleteKeyspace              *connect_go.Client[vtctldata.DeleteKeyspaceRequest, vtctldata.DeleteKeyspaceResponse]
	deleteShards                *connect_go.Client[vtctldata.DeleteShardsRequest, vtctldata.DeleteShardsResponse]
	deleteSrvVSchema            *connect_go.Client[vtctldata.DeleteSrvVSchemaRequest, vtctldata.DeleteSrvVSchemaResponse]
	deleteTablets               *connect_go.Client[vtctldata.DeleteTabletsRequest, vtctldata.DeleteTabletsResponse]
	emergencyReparentShard      *connect_go.Client[vtctldata.EmergencyReparentShardRequest, vtctldata.EmergencyReparentShardResponse]
	executeFetchAsApp           *connect_go.Client[vtctldata.ExecuteFetchAsAppRequest, vtctldata.ExecuteFetchAsAppResponse]
	executeFetchAsDBA           *connect_go.Client[vtctldata.ExecuteFetchAsDBARequest, vtctldata.ExecuteFetchAsDBAResponse]
	executeHook                 *connect_go.Client[vtctldata.ExecuteHookRequest, vtctldata.ExecuteHookResponse]
	findAllShardsInKeyspace     *connect_go.Client[vtctldata.FindAllShardsInKeyspaceRequest, vtctldata.FindAllShardsInKeyspaceResponse]
	getBackups                  *connect_go.Client[vtctldata.GetBackupsRequest, vtctldata.GetBackupsResponse]
	getCellInfo                 *connect_go.Client[vtctldata.GetCellInfoRequest, vtctldata.GetCellInfoResponse]
	getCellInfoNames            *connect_go.Client[vtctldata.GetCellInfoNamesRequest, vtctldata.GetCellInfoNamesResponse]
	getCellsAliases             *connect_go.Client[vtctldata.GetCellsAliasesRequest, vtctldata.GetCellsAliasesResponse]
	getFullStatus               *connect_go.Client[vtctldata.GetFullStatusRequest, vtctldata.GetFullStatusResponse]
	getKeyspace                 *connect_go.Client[vtctldata.GetKeyspaceRequest, vtctldata.GetKeyspaceResponse]
	getKeyspaces                *connect_go.Client[vtctldata.GetKeyspacesRequest, vtctldata.GetKeyspacesResponse]
	getPermissions              *connect_go.Client[vtctldata.GetPermissionsRequest, vtctldata.GetPermissionsResponse]
	getRoutingRules             *connect_go.Client[vtctldata.GetRoutingRulesRequest, vtctldata.GetRoutingRulesResponse]
	getSchema                   *connect_go.Client[vtctldata.GetSchemaRequest, vtctldata.GetSchemaResponse]
	getShard                    *connect_go.Client[vtctldata.GetShardRequest, vtctldata.GetShardResponse]
	getShardRoutingRules        *connect_go.Client[vtctldata.GetShardRoutingRulesRequest, vtctldata.GetShardRoutingRulesResponse]
	getSrvKeyspaceNames         *connect_go.Client[vtctldata.GetSrvKeyspaceNamesRequest, vtctldata.GetSrvKeyspaceNamesResponse]
	getSrvKeyspaces             *connect_go.Client[vtctldata.GetSrvKeyspacesRequest, vtctldata.GetSrvKeyspacesResponse]
	getSrvVSchema               *connect_go.Client[vtctldata.GetSrvVSchemaRequest, vtctldata.GetSrvVSchemaResponse]
	getSrvVSchemas              *connect_go.Client[vtctldata.GetSrvVSchemasRequest, vtctldata.GetSrvVSchemasResponse]
	getTablet                   *connect_go.Client[vtctldata.GetTabletRequest, vtctldata.GetTabletResponse]
	getTablets                  *connect_go.Client[vtctldata.GetTabletsRequest, vtctldata.GetTabletsResponse]
	getVersion                  *connect_go.Client[vtctldata.GetVersionRequest, vtctldata.GetVersionResponse]
	getVSchema                  *connect_go.Client[vtctldata.GetVSchemaRequest, vtctldata.GetVSchemaResponse]
	getWorkflows                *connect_go.Client[vtctldata.GetWorkflowsRequest, vtctldata.GetWorkflowsResponse]
	initShardPrimary            *connect_go.Client[vtctldata.InitShardPrimaryRequest, vtctldata.InitShardPrimaryResponse]
	pingTablet                  *connect_go.Client[vtctldata.PingTabletRequest, vtctldata.PingTabletResponse]
	plannedReparentShard        *connect_go.Client[vtctldata.PlannedReparentShardRequest, vtctldata.PlannedReparentShardResponse]
	rebuildKeyspaceGraph        *connect_go.Client[vtctldata.RebuildKeyspaceGraphRequest, vtctldata.RebuildKeyspaceGraphResponse]
	rebuildVSchemaGraph         *connect_go.Client[vtctldata.RebuildVSchemaGraphRequest, vtctldata.RebuildVSchemaGraphResponse]
	refreshState                *connect_go.Client[vtctldata.RefreshStateRequest, vtctldata.RefreshStateResponse]
	refreshStateByShard         *connect_go.Client[vtctldata.RefreshStateByShardRequest, vtctldata.RefreshStateByShardResponse]
	reloadSchema                *connect_go.Client[vtctldata.ReloadSchemaRequest, vtctldata.ReloadSchemaResponse]
	reloadSchemaKeyspace        *connect_go.Client[vtctldata.ReloadSchemaKeyspaceRequest, vtctldata.ReloadSchemaKeyspaceResponse]
	reloadSchemaShard           *connect_go.Client[vtctldata.ReloadSchemaShardRequest, vtctldata.ReloadSchemaShardResponse]
	removeBackup                *connect_go.Client[vtctldata.RemoveBackupRequest, vtctldata.RemoveBackupResponse]
	removeKeyspaceCell          *connect_go.Client[vtctldata.RemoveKeyspaceCellRequest, vtctldata.RemoveKeyspaceCellResponse]
	removeShardCell             *connect_go.Client[vtctldata.RemoveShardCellRequest, vtctldata.RemoveShardCellResponse]
	reparentTablet              *connect_go.Client[vtctldata.ReparentTabletRequest, vtctldata.ReparentTabletResponse]
	restoreFromBackup           *connect_go.Client[vtctldata.RestoreFromBackupRequest, vtctldata.RestoreFromBackupResponse]
	runHealthCheck              *connect_go.Client[vtctldata.RunHealthCheckRequest, vtctldata.RunHealthCheckResponse]
	setKeyspaceDurabilityPolicy *connect_go.Client[vtctldata.SetKeyspaceDurabilityPolicyRequest, vtctldata.SetKeyspaceDurabilityPolicyResponse]
	setShardIsPrimaryServing    *connect_go.Client[vtctldata.SetShardIsPrimaryServingRequest, vtctldata.SetShardIsPrimaryServingResponse]
	setShardTabletControl       *connect_go.Client[vtctldata.SetShardTabletControlRequest, vtctldata.SetShardTabletControlResponse]
	setWritable                 *connect_go.Client[vtctldata.SetWritableRequest, vtctldata.SetWritableResponse]
	shardReplicationAdd         *connect_go.Client[vtctldata.ShardReplicationAddRequest, vtctldata.ShardReplicationAddResponse]
	shardReplicationFix         *connect_go.Client[vtctldata.ShardReplicationFixRequest, vtctldata.ShardReplicationFixResponse]
	shardReplicationPositions   *connect_go.Client[vtctldata.ShardReplicationPositionsRequest, vtctldata.ShardReplicationPositionsResponse]
	shardReplicationRemove      *connect_go.Client[vtctldata.ShardReplicationRemoveRequest, vtctldata.ShardReplicationRemoveResponse]
	sleepTablet                 *connect_go.Client[vtctldata.SleepTabletRequest, vtctldata.SleepTabletResponse]
	sourceShardAdd              *connect_go.Client[vtctldata.SourceShardAddRequest, vtctldata.SourceShardAddResponse]
	sourceShardDelete           *connect_go.Client[vtctldata.SourceShardDeleteRequest, vtctldata.SourceShardDeleteResponse]
	startReplication            *connect_go.Client[vtctldata.StartReplicationRequest, vtctldata.StartReplicationResponse]
	stopReplication             *connect_go.Client[vtctldata.StopReplicationRequest, vtctldata.StopReplicationResponse]
	tabletExternallyReparented  *connect_go.Client[vtctldata.TabletExternallyReparentedRequest, vtctldata.TabletExternallyReparentedResponse]
	updateCellInfo              *connect_go.Client[vtctldata.UpdateCellInfoRequest, vtctldata.UpdateCellInfoResponse]
	updateCellsAlias            *connect_go.Client[vtctldata.UpdateCellsAliasRequest, vtctldata.UpdateCellsAliasResponse]
	validate                    *connect_go.Client[vtctldata.ValidateRequest, vtctldata.ValidateResponse]
	validateKeyspace            *connect_go.Client[vtctldata.ValidateKeyspaceRequest, vtctldata.ValidateKeyspaceResponse]
	validateSchemaKeyspace      *connect_go.Client[vtctldata.ValidateSchemaKeyspaceRequest, vtctldata.ValidateSchemaKeyspaceResponse]
	validateShard               *connect_go.Client[vtctldata.ValidateShardRequest, vtctldata.ValidateShardResponse]
	validateVersionKeyspace     *connect_go.Client[vtctldata.ValidateVersionKeyspaceRequest, vtctldata.ValidateVersionKeyspaceResponse]
	validateVSchema             *connect_go.Client[vtctldata.ValidateVSchemaRequest, vtctldata.ValidateVSchemaResponse]
}

// AddCellInfo calls vtctlservice.Vtctld.AddCellInfo.
func (c *vtctldClient) AddCellInfo(ctx context.Context, req *connect_go.Request[vtctldata.AddCellInfoRequest]) (*connect_go.Response[vtctldata.AddCellInfoResponse], error) {
	return c.addCellInfo.CallUnary(ctx, req)
}

// AddCellsAlias calls vtctlservice.Vtctld.AddCellsAlias.
func (c *vtctldClient) AddCellsAlias(ctx context.Context, req *connect_go.Request[vtctldata.AddCellsAliasRequest]) (*connect_go.Response[vtctldata.AddCellsAliasResponse], error) {
	return c.addCellsAlias.CallUnary(ctx, req)
}

// ApplyRoutingRules calls vtctlservice.Vtctld.ApplyRoutingRules.
func (c *vtctldClient) ApplyRoutingRules(ctx context.Context, req *connect_go.Request[vtctldata.ApplyRoutingRulesRequest]) (*connect_go.Response[vtctldata.ApplyRoutingRulesResponse], error) {
	return c.applyRoutingRules.CallUnary(ctx, req)
}

// ApplySchema calls vtctlservice.Vtctld.ApplySchema.
func (c *vtctldClient) ApplySchema(ctx context.Context, req *connect_go.Request[vtctldata.ApplySchemaRequest]) (*connect_go.Response[vtctldata.ApplySchemaResponse], error) {
	return c.applySchema.CallUnary(ctx, req)
}

// ApplyShardRoutingRules calls vtctlservice.Vtctld.ApplyShardRoutingRules.
func (c *vtctldClient) ApplyShardRoutingRules(ctx context.Context, req *connect_go.Request[vtctldata.ApplyShardRoutingRulesRequest]) (*connect_go.Response[vtctldata.ApplyShardRoutingRulesResponse], error) {
	return c.applyShardRoutingRules.CallUnary(ctx, req)
}

// ApplyVSchema calls vtctlservice.Vtctld.ApplyVSchema.
func (c *vtctldClient) ApplyVSchema(ctx context.Context, req *connect_go.Request[vtctldata.ApplyVSchemaRequest]) (*connect_go.Response[vtctldata.ApplyVSchemaResponse], error) {
	return c.applyVSchema.CallUnary(ctx, req)
}

// Backup calls vtctlservice.Vtctld.Backup.
func (c *vtctldClient) Backup(ctx context.Context, req *connect_go.Request[vtctldata.BackupRequest]) (*connect_go.ServerStreamForClient[vtctldata.BackupResponse], error) {
	return c.backup.CallServerStream(ctx, req)
}

// BackupShard calls vtctlservice.Vtctld.BackupShard.
func (c *vtctldClient) BackupShard(ctx context.Context, req *connect_go.Request[vtctldata.BackupShardRequest]) (*connect_go.ServerStreamForClient[vtctldata.BackupResponse], error) {
	return c.backupShard.CallServerStream(ctx, req)
}

// ChangeTabletType calls vtctlservice.Vtctld.ChangeTabletType.
func (c *vtctldClient) ChangeTabletType(ctx context.Context, req *connect_go.Request[vtctldata.ChangeTabletTypeRequest]) (*connect_go.Response[vtctldata.ChangeTabletTypeResponse], error) {
	return c.changeTabletType.CallUnary(ctx, req)
}

// CreateKeyspace calls vtctlservice.Vtctld.CreateKeyspace.
func (c *vtctldClient) CreateKeyspace(ctx context.Context, req *connect_go.Request[vtctldata.CreateKeyspaceRequest]) (*connect_go.Response[vtctldata.CreateKeyspaceResponse], error) {
	return c.createKeyspace.CallUnary(ctx, req)
}

// CreateShard calls vtctlservice.Vtctld.CreateShard.
func (c *vtctldClient) CreateShard(ctx context.Context, req *connect_go.Request[vtctldata.CreateShardRequest]) (*connect_go.Response[vtctldata.CreateShardResponse], error) {
	return c.createShard.CallUnary(ctx, req)
}

// DeleteCellInfo calls vtctlservice.Vtctld.DeleteCellInfo.
func (c *vtctldClient) DeleteCellInfo(ctx context.Context, req *connect_go.Request[vtctldata.DeleteCellInfoRequest]) (*connect_go.Response[vtctldata.DeleteCellInfoResponse], error) {
	return c.deleteCellInfo.CallUnary(ctx, req)
}

// DeleteCellsAlias calls vtctlservice.Vtctld.DeleteCellsAlias.
func (c *vtctldClient) DeleteCellsAlias(ctx context.Context, req *connect_go.Request[vtctldata.DeleteCellsAliasRequest]) (*connect_go.Response[vtctldata.DeleteCellsAliasResponse], error) {
	return c.deleteCellsAlias.CallUnary(ctx, req)
}

// DeleteKeyspace calls vtctlservice.Vtctld.DeleteKeyspace.
func (c *vtctldClient) DeleteKeyspace(ctx context.Context, req *connect_go.Request[vtctldata.DeleteKeyspaceRequest]) (*connect_go.Response[vtctldata.DeleteKeyspaceResponse], error) {
	return c.deleteKeyspace.CallUnary(ctx, req)
}

// DeleteShards calls vtctlservice.Vtctld.DeleteShards.
func (c *vtctldClient) DeleteShards(ctx context.Context, req *connect_go.Request[vtctldata.DeleteShardsRequest]) (*connect_go.Response[vtctldata.DeleteShardsResponse], error) {
	return c.deleteShards.CallUnary(ctx, req)
}

// DeleteSrvVSchema calls vtctlservice.Vtctld.DeleteSrvVSchema.
func (c *vtctldClient) DeleteSrvVSchema(ctx context.Context, req *connect_go.Request[vtctldata.DeleteSrvVSchemaRequest]) (*connect_go.Response[vtctldata.DeleteSrvVSchemaResponse], error) {
	return c.deleteSrvVSchema.CallUnary(ctx, req)
}

// DeleteTablets calls vtctlservice.Vtctld.DeleteTablets.
func (c *vtctldClient) DeleteTablets(ctx context.Context, req *connect_go.Request[vtctldata.DeleteTabletsRequest]) (*connect_go.Response[vtctldata.DeleteTabletsResponse], error) {
	return c.deleteTablets.CallUnary(ctx, req)
}

// EmergencyReparentShard calls vtctlservice.Vtctld.EmergencyReparentShard.
func (c *vtctldClient) EmergencyReparentShard(ctx context.Context, req *connect_go.Request[vtctldata.EmergencyReparentShardRequest]) (*connect_go.Response[vtctldata.EmergencyReparentShardResponse], error) {
	return c.emergencyReparentShard.CallUnary(ctx, req)
}

// ExecuteFetchAsApp calls vtctlservice.Vtctld.ExecuteFetchAsApp.
func (c *vtctldClient) ExecuteFetchAsApp(ctx context.Context, req *connect_go.Request[vtctldata.ExecuteFetchAsAppRequest]) (*connect_go.Response[vtctldata.ExecuteFetchAsAppResponse], error) {
	return c.executeFetchAsApp.CallUnary(ctx, req)
}

// ExecuteFetchAsDBA calls vtctlservice.Vtctld.ExecuteFetchAsDBA.
func (c *vtctldClient) ExecuteFetchAsDBA(ctx context.Context, req *connect_go.Request[vtctldata.ExecuteFetchAsDBARequest]) (*connect_go.Response[vtctldata.ExecuteFetchAsDBAResponse], error) {
	return c.executeFetchAsDBA.CallUnary(ctx, req)
}

// ExecuteHook calls vtctlservice.Vtctld.ExecuteHook.
func (c *vtctldClient) ExecuteHook(ctx context.Context, req *connect_go.Request[vtctldata.ExecuteHookRequest]) (*connect_go.Response[vtctldata.ExecuteHookResponse], error) {
	return c.executeHook.CallUnary(ctx, req)
}

// FindAllShardsInKeyspace calls vtctlservice.Vtctld.FindAllShardsInKeyspace.
func (c *vtctldClient) FindAllShardsInKeyspace(ctx context.Context, req *connect_go.Request[vtctldata.FindAllShardsInKeyspaceRequest]) (*connect_go.Response[vtctldata.FindAllShardsInKeyspaceResponse], error) {
	return c.findAllShardsInKeyspace.CallUnary(ctx, req)
}

// GetBackups calls vtctlservice.Vtctld.GetBackups.
func (c *vtctldClient) GetBackups(ctx context.Context, req *connect_go.Request[vtctldata.GetBackupsRequest]) (*connect_go.Response[vtctldata.GetBackupsResponse], error) {
	return c.getBackups.CallUnary(ctx, req)
}

// GetCellInfo calls vtctlservice.Vtctld.GetCellInfo.
func (c *vtctldClient) GetCellInfo(ctx context.Context, req *connect_go.Request[vtctldata.GetCellInfoRequest]) (*connect_go.Response[vtctldata.GetCellInfoResponse], error) {
	return c.getCellInfo.CallUnary(ctx, req)
}

// GetCellInfoNames calls vtctlservice.Vtctld.GetCellInfoNames.
func (c *vtctldClient) GetCellInfoNames(ctx context.Context, req *connect_go.Request[vtctldata.GetCellInfoNamesRequest]) (*connect_go.Response[vtctldata.GetCellInfoNamesResponse], error) {
	return c.getCellInfoNames.CallUnary(ctx, req)
}

// GetCellsAliases calls vtctlservice.Vtctld.GetCellsAliases.
func (c *vtctldClient) GetCellsAliases(ctx context.Context, req *connect_go.Request[vtctldata.GetCellsAliasesRequest]) (*connect_go.Response[vtctldata.GetCellsAliasesResponse], error) {
	return c.getCellsAliases.CallUnary(ctx, req)
}

// GetFullStatus calls vtctlservice.Vtctld.GetFullStatus.
func (c *vtctldClient) GetFullStatus(ctx context.Context, req *connect_go.Request[vtctldata.GetFullStatusRequest]) (*connect_go.Response[vtctldata.GetFullStatusResponse], error) {
	return c.getFullStatus.CallUnary(ctx, req)
}

// GetKeyspace calls vtctlservice.Vtctld.GetKeyspace.
func (c *vtctldClient) GetKeyspace(ctx context.Context, req *connect_go.Request[vtctldata.GetKeyspaceRequest]) (*connect_go.Response[vtctldata.GetKeyspaceResponse], error) {
	return c.getKeyspace.CallUnary(ctx, req)
}

// GetKeyspaces calls vtctlservice.Vtctld.GetKeyspaces.
func (c *vtctldClient) GetKeyspaces(ctx context.Context, req *connect_go.Request[vtctldata.GetKeyspacesRequest]) (*connect_go.Response[vtctldata.GetKeyspacesResponse], error) {
	return c.getKeyspaces.CallUnary(ctx, req)
}

// GetPermissions calls vtctlservice.Vtctld.GetPermissions.
func (c *vtctldClient) GetPermissions(ctx context.Context, req *connect_go.Request[vtctldata.GetPermissionsRequest]) (*connect_go.Response[vtctldata.GetPermissionsResponse], error) {
	return c.getPermissions.CallUnary(ctx, req)
}

// GetRoutingRules calls vtctlservice.Vtctld.GetRoutingRules.
func (c *vtctldClient) GetRoutingRules(ctx context.Context, req *connect_go.Request[vtctldata.GetRoutingRulesRequest]) (*connect_go.Response[vtctldata.GetRoutingRulesResponse], error) {
	return c.getRoutingRules.CallUnary(ctx, req)
}

// GetSchema calls vtctlservice.Vtctld.GetSchema.
func (c *vtctldClient) GetSchema(ctx context.Context, req *connect_go.Request[vtctldata.GetSchemaRequest]) (*connect_go.Response[vtctldata.GetSchemaResponse], error) {
	return c.getSchema.CallUnary(ctx, req)
}

// GetShard calls vtctlservice.Vtctld.GetShard.
func (c *vtctldClient) GetShard(ctx context.Context, req *connect_go.Request[vtctldata.GetShardRequest]) (*connect_go.Response[vtctldata.GetShardResponse], error) {
	return c.getShard.CallUnary(ctx, req)
}

// GetShardRoutingRules calls vtctlservice.Vtctld.GetShardRoutingRules.
func (c *vtctldClient) GetShardRoutingRules(ctx context.Context, req *connect_go.Request[vtctldata.GetShardRoutingRulesRequest]) (*connect_go.Response[vtctldata.GetShardRoutingRulesResponse], error) {
	return c.getShardRoutingRules.CallUnary(ctx, req)
}

// GetSrvKeyspaceNames calls vtctlservice.Vtctld.GetSrvKeyspaceNames.
func (c *vtctldClient) GetSrvKeyspaceNames(ctx context.Context, req *connect_go.Request[vtctldata.GetSrvKeyspaceNamesRequest]) (*connect_go.Response[vtctldata.GetSrvKeyspaceNamesResponse], error) {
	return c.getSrvKeyspaceNames.CallUnary(ctx, req)
}

// GetSrvKeyspaces calls vtctlservice.Vtctld.GetSrvKeyspaces.
func (c *vtctldClient) GetSrvKeyspaces(ctx context.Context, req *connect_go.Request[vtctldata.GetSrvKeyspacesRequest]) (*connect_go.Response[vtctldata.GetSrvKeyspacesResponse], error) {
	return c.getSrvKeyspaces.CallUnary(ctx, req)
}

// GetSrvVSchema calls vtctlservice.Vtctld.GetSrvVSchema.
func (c *vtctldClient) GetSrvVSchema(ctx context.Context, req *connect_go.Request[vtctldata.GetSrvVSchemaRequest]) (*connect_go.Response[vtctldata.GetSrvVSchemaResponse], error) {
	return c.getSrvVSchema.CallUnary(ctx, req)
}

// GetSrvVSchemas calls vtctlservice.Vtctld.GetSrvVSchemas.
func (c *vtctldClient) GetSrvVSchemas(ctx context.Context, req *connect_go.Request[vtctldata.GetSrvVSchemasRequest]) (*connect_go.Response[vtctldata.GetSrvVSchemasResponse], error) {
	return c.getSrvVSchemas.CallUnary(ctx, req)
}

// GetTablet calls vtctlservice.Vtctld.GetTablet.
func (c *vtctldClient) GetTablet(ctx context.Context, req *connect_go.Request[vtctldata.GetTabletRequest]) (*connect_go.Response[vtctldata.GetTabletResponse], error) {
	return c.getTablet.CallUnary(ctx, req)
}

// GetTablets calls vtctlservice.Vtctld.GetTablets.
func (c *vtctldClient) GetTablets(ctx context.Context, req *connect_go.Request[vtctldata.GetTabletsRequest]) (*connect_go.Response[vtctldata.GetTabletsResponse], error) {
	return c.getTablets.CallUnary(ctx, req)
}

// GetVersion calls vtctlservice.Vtctld.GetVersion.
func (c *vtctldClient) GetVersion(ctx context.Context, req *connect_go.Request[vtctldata.GetVersionRequest]) (*connect_go.Response[vtctldata.GetVersionResponse], error) {
	return c.getVersion.CallUnary(ctx, req)
}

// GetVSchema calls vtctlservice.Vtctld.GetVSchema.
func (c *vtctldClient) GetVSchema(ctx context.Context, req *connect_go.Request[vtctldata.GetVSchemaRequest]) (*connect_go.Response[vtctldata.GetVSchemaResponse], error) {
	return c.getVSchema.CallUnary(ctx, req)
}

// GetWorkflows calls vtctlservice.Vtctld.GetWorkflows.
func (c *vtctldClient) GetWorkflows(ctx context.Context, req *connect_go.Request[vtctldata.GetWorkflowsRequest]) (*connect_go.Response[vtctldata.GetWorkflowsResponse], error) {
	return c.getWorkflows.CallUnary(ctx, req)
}

// InitShardPrimary calls vtctlservice.Vtctld.InitShardPrimary.
func (c *vtctldClient) InitShardPrimary(ctx context.Context, req *connect_go.Request[vtctldata.InitShardPrimaryRequest]) (*connect_go.Response[vtctldata.InitShardPrimaryResponse], error) {
	return c.initShardPrimary.CallUnary(ctx, req)
}

// PingTablet calls vtctlservice.Vtctld.PingTablet.
func (c *vtctldClient) PingTablet(ctx context.Context, req *connect_go.Request[vtctldata.PingTabletRequest]) (*connect_go.Response[vtctldata.PingTabletResponse], error) {
	return c.pingTablet.CallUnary(ctx, req)
}

// PlannedReparentShard calls vtctlservice.Vtctld.PlannedReparentShard.
func (c *vtctldClient) PlannedReparentShard(ctx context.Context, req *connect_go.Request[vtctldata.PlannedReparentShardRequest]) (*connect_go.Response[vtctldata.PlannedReparentShardResponse], error) {
	return c.plannedReparentShard.CallUnary(ctx, req)
}

// RebuildKeyspaceGraph calls vtctlservice.Vtctld.RebuildKeyspaceGraph.
func (c *vtctldClient) RebuildKeyspaceGraph(ctx context.Context, req *connect_go.Request[vtctldata.RebuildKeyspaceGraphRequest]) (*connect_go.Response[vtctldata.RebuildKeyspaceGraphResponse], error) {
	return c.rebuildKeyspaceGraph.CallUnary(ctx, req)
}

// RebuildVSchemaGraph calls vtctlservice.Vtctld.RebuildVSchemaGraph.
func (c *vtctldClient) RebuildVSchemaGraph(ctx context.Context, req *connect_go.Request[vtctldata.RebuildVSchemaGraphRequest]) (*connect_go.Response[vtctldata.RebuildVSchemaGraphResponse], error) {
	return c.rebuildVSchemaGraph.CallUnary(ctx, req)
}

// RefreshState calls vtctlservice.Vtctld.RefreshState.
func (c *vtctldClient) RefreshState(ctx context.Context, req *connect_go.Request[vtctldata.RefreshStateRequest]) (*connect_go.Response[vtctldata.RefreshStateResponse], error) {
	return c.refreshState.CallUnary(ctx, req)
}

// RefreshStateByShard calls vtctlservice.Vtctld.RefreshStateByShard.
func (c *vtctldClient) RefreshStateByShard(ctx context.Context, req *connect_go.Request[vtctldata.RefreshStateByShardRequest]) (*connect_go.Response[vtctldata.RefreshStateByShardResponse], error) {
	return c.refreshStateByShard.CallUnary(ctx, req)
}

// ReloadSchema calls vtctlservice.Vtctld.ReloadSchema.
func (c *vtctldClient) ReloadSchema(ctx context.Context, req *connect_go.Request[vtctldata.ReloadSchemaRequest]) (*connect_go.Response[vtctldata.ReloadSchemaResponse], error) {
	return c.reloadSchema.CallUnary(ctx, req)
}

// ReloadSchemaKeyspace calls vtctlservice.Vtctld.ReloadSchemaKeyspace.
func (c *vtctldClient) ReloadSchemaKeyspace(ctx context.Context, req *connect_go.Request[vtctldata.ReloadSchemaKeyspaceRequest]) (*connect_go.Response[vtctldata.ReloadSchemaKeyspaceResponse], error) {
	return c.reloadSchemaKeyspace.CallUnary(ctx, req)
}

// ReloadSchemaShard calls vtctlservice.Vtctld.ReloadSchemaShard.
func (c *vtctldClient) ReloadSchemaShard(ctx context.Context, req *connect_go.Request[vtctldata.ReloadSchemaShardRequest]) (*connect_go.Response[vtctldata.ReloadSchemaShardResponse], error) {
	return c.reloadSchemaShard.CallUnary(ctx, req)
}

// RemoveBackup calls vtctlservice.Vtctld.RemoveBackup.
func (c *vtctldClient) RemoveBackup(ctx context.Context, req *connect_go.Request[vtctldata.RemoveBackupRequest]) (*connect_go.Response[vtctldata.RemoveBackupResponse], error) {
	return c.removeBackup.CallUnary(ctx, req)
}

// RemoveKeyspaceCell calls vtctlservice.Vtctld.RemoveKeyspaceCell.
func (c *vtctldClient) RemoveKeyspaceCell(ctx context.Context, req *connect_go.Request[vtctldata.RemoveKeyspaceCellRequest]) (*connect_go.Response[vtctldata.RemoveKeyspaceCellResponse], error) {
	return c.removeKeyspaceCell.CallUnary(ctx, req)
}

// RemoveShardCell calls vtctlservice.Vtctld.RemoveShardCell.
func (c *vtctldClient) RemoveShardCell(ctx context.Context, req *connect_go.Request[vtctldata.RemoveShardCellRequest]) (*connect_go.Response[vtctldata.RemoveShardCellResponse], error) {
	return c.removeShardCell.CallUnary(ctx, req)
}

// ReparentTablet calls vtctlservice.Vtctld.ReparentTablet.
func (c *vtctldClient) ReparentTablet(ctx context.Context, req *connect_go.Request[vtctldata.ReparentTabletRequest]) (*connect_go.Response[vtctldata.ReparentTabletResponse], error) {
	return c.reparentTablet.CallUnary(ctx, req)
}

// RestoreFromBackup calls vtctlservice.Vtctld.RestoreFromBackup.
func (c *vtctldClient) RestoreFromBackup(ctx context.Context, req *connect_go.Request[vtctldata.RestoreFromBackupRequest]) (*connect_go.ServerStreamForClient[vtctldata.RestoreFromBackupResponse], error) {
	return c.restoreFromBackup.CallServerStream(ctx, req)
}

// RunHealthCheck calls vtctlservice.Vtctld.RunHealthCheck.
func (c *vtctldClient) RunHealthCheck(ctx context.Context, req *connect_go.Request[vtctldata.RunHealthCheckRequest]) (*connect_go.Response[vtctldata.RunHealthCheckResponse], error) {
	return c.runHealthCheck.CallUnary(ctx, req)
}

// SetKeyspaceDurabilityPolicy calls vtctlservice.Vtctld.SetKeyspaceDurabilityPolicy.
func (c *vtctldClient) SetKeyspaceDurabilityPolicy(ctx context.Context, req *connect_go.Request[vtctldata.SetKeyspaceDurabilityPolicyRequest]) (*connect_go.Response[vtctldata.SetKeyspaceDurabilityPolicyResponse], error) {
	return c.setKeyspaceDurabilityPolicy.CallUnary(ctx, req)
}

// SetShardIsPrimaryServing calls vtctlservice.Vtctld.SetShardIsPrimaryServing.
func (c *vtctldClient) SetShardIsPrimaryServing(ctx context.Context, req *connect_go.Request[vtctldata.SetShardIsPrimaryServingRequest]) (*connect_go.Response[vtctldata.SetShardIsPrimaryServingResponse], error) {
	return c.setShardIsPrimaryServing.CallUnary(ctx, req)
}

// SetShardTabletControl calls vtctlservice.Vtctld.SetShardTabletControl.
func (c *vtctldClient) SetShardTabletControl(ctx context.Context, req *connect_go.Request[vtctldata.SetShardTabletControlRequest]) (*connect_go.Response[vtctldata.SetShardTabletControlResponse], error) {
	return c.setShardTabletControl.CallUnary(ctx, req)
}

// SetWritable calls vtctlservice.Vtctld.SetWritable.
func (c *vtctldClient) SetWritable(ctx context.Context, req *connect_go.Request[vtctldata.SetWritableRequest]) (*connect_go.Response[vtctldata.SetWritableResponse], error) {
	return c.setWritable.CallUnary(ctx, req)
}

// ShardReplicationAdd calls vtctlservice.Vtctld.ShardReplicationAdd.
func (c *vtctldClient) ShardReplicationAdd(ctx context.Context, req *connect_go.Request[vtctldata.ShardReplicationAddRequest]) (*connect_go.Response[vtctldata.ShardReplicationAddResponse], error) {
	return c.shardReplicationAdd.CallUnary(ctx, req)
}

// ShardReplicationFix calls vtctlservice.Vtctld.ShardReplicationFix.
func (c *vtctldClient) ShardReplicationFix(ctx context.Context, req *connect_go.Request[vtctldata.ShardReplicationFixRequest]) (*connect_go.Response[vtctldata.ShardReplicationFixResponse], error) {
	return c.shardReplicationFix.CallUnary(ctx, req)
}

// ShardReplicationPositions calls vtctlservice.Vtctld.ShardReplicationPositions.
func (c *vtctldClient) ShardReplicationPositions(ctx context.Context, req *connect_go.Request[vtctldata.ShardReplicationPositionsRequest]) (*connect_go.Response[vtctldata.ShardReplicationPositionsResponse], error) {
	return c.shardReplicationPositions.CallUnary(ctx, req)
}

// ShardReplicationRemove calls vtctlservice.Vtctld.ShardReplicationRemove.
func (c *vtctldClient) ShardReplicationRemove(ctx context.Context, req *connect_go.Request[vtctldata.ShardReplicationRemoveRequest]) (*connect_go.Response[vtctldata.ShardReplicationRemoveResponse], error) {
	return c.shardReplicationRemove.CallUnary(ctx, req)
}

// SleepTablet calls vtctlservice.Vtctld.SleepTablet.
func (c *vtctldClient) SleepTablet(ctx context.Context, req *connect_go.Request[vtctldata.SleepTabletRequest]) (*connect_go.Response[vtctldata.SleepTabletResponse], error) {
	return c.sleepTablet.CallUnary(ctx, req)
}

// SourceShardAdd calls vtctlservice.Vtctld.SourceShardAdd.
func (c *vtctldClient) SourceShardAdd(ctx context.Context, req *connect_go.Request[vtctldata.SourceShardAddRequest]) (*connect_go.Response[vtctldata.SourceShardAddResponse], error) {
	return c.sourceShardAdd.CallUnary(ctx, req)
}

// SourceShardDelete calls vtctlservice.Vtctld.SourceShardDelete.
func (c *vtctldClient) SourceShardDelete(ctx context.Context, req *connect_go.Request[vtctldata.SourceShardDeleteRequest]) (*connect_go.Response[vtctldata.SourceShardDeleteResponse], error) {
	return c.sourceShardDelete.CallUnary(ctx, req)
}

// StartReplication calls vtctlservice.Vtctld.StartReplication.
func (c *vtctldClient) StartReplication(ctx context.Context, req *connect_go.Request[vtctldata.StartReplicationRequest]) (*connect_go.Response[vtctldata.StartReplicationResponse], error) {
	return c.startReplication.CallUnary(ctx, req)
}

// StopReplication calls vtctlservice.Vtctld.StopReplication.
func (c *vtctldClient) StopReplication(ctx context.Context, req *connect_go.Request[vtctldata.StopReplicationRequest]) (*connect_go.Response[vtctldata.StopReplicationResponse], error) {
	return c.stopReplication.CallUnary(ctx, req)
}

// TabletExternallyReparented calls vtctlservice.Vtctld.TabletExternallyReparented.
func (c *vtctldClient) TabletExternallyReparented(ctx context.Context, req *connect_go.Request[vtctldata.TabletExternallyReparentedRequest]) (*connect_go.Response[vtctldata.TabletExternallyReparentedResponse], error) {
	return c.tabletExternallyReparented.CallUnary(ctx, req)
}

// UpdateCellInfo calls vtctlservice.Vtctld.UpdateCellInfo.
func (c *vtctldClient) UpdateCellInfo(ctx context.Context, req *connect_go.Request[vtctldata.UpdateCellInfoRequest]) (*connect_go.Response[vtctldata.UpdateCellInfoResponse], error) {
	return c.updateCellInfo.CallUnary(ctx, req)
}

// UpdateCellsAlias calls vtctlservice.Vtctld.UpdateCellsAlias.
func (c *vtctldClient) UpdateCellsAlias(ctx context.Context, req *connect_go.Request[vtctldata.UpdateCellsAliasRequest]) (*connect_go.Response[vtctldata.UpdateCellsAliasResponse], error) {
	return c.updateCellsAlias.CallUnary(ctx, req)
}

// Validate calls vtctlservice.Vtctld.Validate.
func (c *vtctldClient) Validate(ctx context.Context, req *connect_go.Request[vtctldata.ValidateRequest]) (*connect_go.Response[vtctldata.ValidateResponse], error) {
	return c.validate.CallUnary(ctx, req)
}

// ValidateKeyspace calls vtctlservice.Vtctld.ValidateKeyspace.
func (c *vtctldClient) ValidateKeyspace(ctx context.Context, req *connect_go.Request[vtctldata.ValidateKeyspaceRequest]) (*connect_go.Response[vtctldata.ValidateKeyspaceResponse], error) {
	return c.validateKeyspace.CallUnary(ctx, req)
}

// ValidateSchemaKeyspace calls vtctlservice.Vtctld.ValidateSchemaKeyspace.
func (c *vtctldClient) ValidateSchemaKeyspace(ctx context.Context, req *connect_go.Request[vtctldata.ValidateSchemaKeyspaceRequest]) (*connect_go.Response[vtctldata.ValidateSchemaKeyspaceResponse], error) {
	return c.validateSchemaKeyspace.CallUnary(ctx, req)
}

// ValidateShard calls vtctlservice.Vtctld.ValidateShard.
func (c *vtctldClient) ValidateShard(ctx context.Context, req *connect_go.Request[vtctldata.ValidateShardRequest]) (*connect_go.Response[vtctldata.ValidateShardResponse], error) {
	return c.validateShard.CallUnary(ctx, req)
}

// ValidateVersionKeyspace calls vtctlservice.Vtctld.ValidateVersionKeyspace.
func (c *vtctldClient) ValidateVersionKeyspace(ctx context.Context, req *connect_go.Request[vtctldata.ValidateVersionKeyspaceRequest]) (*connect_go.Response[vtctldata.ValidateVersionKeyspaceResponse], error) {
	return c.validateVersionKeyspace.CallUnary(ctx, req)
}

// ValidateVSchema calls vtctlservice.Vtctld.ValidateVSchema.
func (c *vtctldClient) ValidateVSchema(ctx context.Context, req *connect_go.Request[vtctldata.ValidateVSchemaRequest]) (*connect_go.Response[vtctldata.ValidateVSchemaResponse], error) {
	return c.validateVSchema.CallUnary(ctx, req)
}

// VtctldHandler is an implementation of the vtctlservice.Vtctld service.
type VtctldHandler interface {
	// AddCellInfo registers a local topology service in a new cell by creating
	// the CellInfo with the provided parameters.
	AddCellInfo(context.Context, *connect_go.Request[vtctldata.AddCellInfoRequest]) (*connect_go.Response[vtctldata.AddCellInfoResponse], error)
	// AddCellsAlias defines a group of cells that can be referenced by a single
	// name (the alias).
	//
	// When routing query traffic, replica/rdonly traffic can be routed across
	// cells within the group (alias). Only primary traffic can be routed across
	// cells not in the same group (alias).
	AddCellsAlias(context.Context, *connect_go.Request[vtctldata.AddCellsAliasRequest]) (*connect_go.Response[vtctldata.AddCellsAliasResponse], error)
	// ApplyRoutingRules applies the VSchema routing rules.
	ApplyRoutingRules(context.Context, *connect_go.Request[vtctldata.ApplyRoutingRulesRequest]) (*connect_go.Response[vtctldata.ApplyRoutingRulesResponse], error)
	// ApplySchema applies a schema to a keyspace.
	ApplySchema(context.Context, *connect_go.Request[vtctldata.ApplySchemaRequest]) (*connect_go.Response[vtctldata.ApplySchemaResponse], error)
	// ApplyShardRoutingRules applies the VSchema shard routing rules.
	ApplyShardRoutingRules(context.Context, *connect_go.Request[vtctldata.ApplyShardRoutingRulesRequest]) (*connect_go.Response[vtctldata.ApplyShardRoutingRulesResponse], error)
	// ApplyVSchema applies a vschema to a keyspace.
	ApplyVSchema(context.Context, *connect_go.Request[vtctldata.ApplyVSchemaRequest]) (*connect_go.Response[vtctldata.ApplyVSchemaResponse], error)
	// Backup uses the BackupEngine and BackupStorage services on the specified
	// tablet to create and store a new backup.
	Backup(context.Context, *connect_go.Request[vtctldata.BackupRequest], *connect_go.ServerStream[vtctldata.BackupResponse]) error
	// BackupShard chooses a tablet in the shard and uses it to create a backup.
	BackupShard(context.Context, *connect_go.Request[vtctldata.BackupShardRequest], *connect_go.ServerStream[vtctldata.BackupResponse]) error
	// ChangeTabletType changes the db type for the specified tablet, if possible.
	// This is used primarily to arrange replicas, and it will not convert a
	// primary. For that, use InitShardPrimary.
	//
	// NOTE: This command automatically updates the serving graph.
	ChangeTabletType(context.Context, *connect_go.Request[vtctldata.ChangeTabletTypeRequest]) (*connect_go.Response[vtctldata.ChangeTabletTypeResponse], error)
	// CreateKeyspace creates the specified keyspace in the topology. For a
	// SNAPSHOT keyspace, the request must specify the name of a base keyspace,
	// as well as a snapshot time.
	CreateKeyspace(context.Context, *connect_go.Request[vtctldata.CreateKeyspaceRequest]) (*connect_go.Response[vtctldata.CreateKeyspaceResponse], error)
	// CreateShard creates the specified shard in the topology.
	CreateShard(context.Context, *connect_go.Request[vtctldata.CreateShardRequest]) (*connect_go.Response[vtctldata.CreateShardResponse], error)
	// DeleteCellInfo deletes the CellInfo for the provided cell. The cell cannot
	// be referenced by any Shard record in the topology.
	DeleteCellInfo(context.Context, *connect_go.Request[vtctldata.DeleteCellInfoRequest]) (*connect_go.Response[vtctldata.DeleteCellInfoResponse], error)
	// DeleteCellsAlias deletes the CellsAlias for the provided alias.
	DeleteCellsAlias(context.Context, *connect_go.Request[vtctldata.DeleteCellsAliasRequest]) (*connect_go.Response[vtctldata.DeleteCellsAliasResponse], error)
	// DeleteKeyspace deletes the specified keyspace from the topology. In
	// recursive mode, it also recursively deletes all shards in the keyspace.
	// Otherwise, the keyspace must be empty (have no shards), or DeleteKeyspace
	// returns an error.
	DeleteKeyspace(context.Context, *connect_go.Request[vtctldata.DeleteKeyspaceRequest]) (*connect_go.Response[vtctldata.DeleteKeyspaceResponse], error)
	// DeleteShards deletes the specified shards from the topology. In recursive
	// mode, it also deletes all tablets belonging to the shard. Otherwise, the
	// shard must be empty (have no tablets) or DeleteShards returns an error for
	// that shard.
	DeleteShards(context.Context, *connect_go.Request[vtctldata.DeleteShardsRequest]) (*connect_go.Response[vtctldata.DeleteShardsResponse], error)
	// DeleteSrvVSchema deletes the SrvVSchema object in the specified cell.
	DeleteSrvVSchema(context.Context, *connect_go.Request[vtctldata.DeleteSrvVSchemaRequest]) (*connect_go.Response[vtctldata.DeleteSrvVSchemaResponse], error)
	// DeleteTablets deletes one or more tablets from the topology.
	DeleteTablets(context.Context, *connect_go.Request[vtctldata.DeleteTabletsRequest]) (*connect_go.Response[vtctldata.DeleteTabletsResponse], error)
	// EmergencyReparentShard reparents the shard to the new primary. It assumes
	// the old primary is dead or otherwise not responding.
	EmergencyReparentShard(context.Context, *connect_go.Request[vtctldata.EmergencyReparentShardRequest]) (*connect_go.Response[vtctldata.EmergencyReparentShardResponse], error)
	// ExecuteFetchAsApp executes a SQL query on the remote tablet as the App user.
	ExecuteFetchAsApp(context.Context, *connect_go.Request[vtctldata.ExecuteFetchAsAppRequest]) (*connect_go.Response[vtctldata.ExecuteFetchAsAppResponse], error)
	// ExecuteFetchAsDBA executes a SQL query on the remote tablet as the DBA user.
	ExecuteFetchAsDBA(context.Context, *connect_go.Request[vtctldata.ExecuteFetchAsDBARequest]) (*connect_go.Response[vtctldata.ExecuteFetchAsDBAResponse], error)
	// ExecuteHook runs the hook on the tablet.
	ExecuteHook(context.Context, *connect_go.Request[vtctldata.ExecuteHookRequest]) (*connect_go.Response[vtctldata.ExecuteHookResponse], error)
	// FindAllShardsInKeyspace returns a map of shard names to shard references
	// for a given keyspace.
	FindAllShardsInKeyspace(context.Context, *connect_go.Request[vtctldata.FindAllShardsInKeyspaceRequest]) (*connect_go.Response[vtctldata.FindAllShardsInKeyspaceResponse], error)
	// GetBackups returns all the backups for a shard.
	GetBackups(context.Context, *connect_go.Request[vtctldata.GetBackupsRequest]) (*connect_go.Response[vtctldata.GetBackupsResponse], error)
	// GetCellInfo returns the information for a cell.
	GetCellInfo(context.Context, *connect_go.Request[vtctldata.GetCellInfoRequest]) (*connect_go.Response[vtctldata.GetCellInfoResponse], error)
	// GetCellInfoNames returns all the cells for which we have a CellInfo object,
	// meaning we have a topology service registered.
	GetCellInfoNames(context.Context, *connect_go.Request[vtctldata.GetCellInfoNamesRequest]) (*connect_go.Response[vtctldata.GetCellInfoNamesResponse], error)
	// GetCellsAliases returns a mapping of cell alias to cells identified by that
	// alias.
	GetCellsAliases(context.Context, *connect_go.Request[vtctldata.GetCellsAliasesRequest]) (*connect_go.Response[vtctldata.GetCellsAliasesResponse], error)
	// GetFullStatus returns the full status of MySQL including the replication information, semi-sync information, GTID information among others
	GetFullStatus(context.Context, *connect_go.Request[vtctldata.GetFullStatusRequest]) (*connect_go.Response[vtctldata.GetFullStatusResponse], error)
	// GetKeyspace reads the given keyspace from the topo and returns it.
	GetKeyspace(context.Context, *connect_go.Request[vtctldata.GetKeyspaceRequest]) (*connect_go.Response[vtctldata.GetKeyspaceResponse], error)
	// GetKeyspaces returns the keyspace struct of all keyspaces in the topo.
	GetKeyspaces(context.Context, *connect_go.Request[vtctldata.GetKeyspacesRequest]) (*connect_go.Response[vtctldata.GetKeyspacesResponse], error)
	// GetPermissions returns the permissions set on the remote tablet.
	GetPermissions(context.Context, *connect_go.Request[vtctldata.GetPermissionsRequest]) (*connect_go.Response[vtctldata.GetPermissionsResponse], error)
	// GetRoutingRules returns the VSchema routing rules.
	GetRoutingRules(context.Context, *connect_go.Request[vtctldata.GetRoutingRulesRequest]) (*connect_go.Response[vtctldata.GetRoutingRulesResponse], error)
	// GetSchema returns the schema for a tablet, or just the schema for the
	// specified tables in that tablet.
	GetSchema(context.Context, *connect_go.Request[vtctldata.GetSchemaRequest]) (*connect_go.Response[vtctldata.GetSchemaResponse], error)
	// GetShard returns information about a shard in the topology.
	GetShard(context.Context, *connect_go.Request[vtctldata.GetShardRequest]) (*connect_go.Response[vtctldata.GetShardResponse], error)
	// GetShardRoutingRules returns the VSchema shard routing rules.
	GetShardRoutingRules(context.Context, *connect_go.Request[vtctldata.GetShardRoutingRulesRequest]) (*connect_go.Response[vtctldata.GetShardRoutingRulesResponse], error)
	// GetSrvKeyspaceNames returns a mapping of cell name to the keyspaces served
	// in that cell.
	GetSrvKeyspaceNames(context.Context, *connect_go.Request[vtctldata.GetSrvKeyspaceNamesRequest]) (*connect_go.Response[vtctldata.GetSrvKeyspaceNamesResponse], error)
	// GetSrvKeyspaces returns the SrvKeyspaces for a keyspace in one or more
	// cells.
	GetSrvKeyspaces(context.Context, *connect_go.Request[vtctldata.GetSrvKeyspacesRequest]) (*connect_go.Response[vtctldata.GetSrvKeyspacesResponse], error)
	// GetSrvVSchema returns the SrvVSchema for a cell.
	GetSrvVSchema(context.Context, *connect_go.Request[vtctldata.GetSrvVSchemaRequest]) (*connect_go.Response[vtctldata.GetSrvVSchemaResponse], error)
	// GetSrvVSchemas returns a mapping from cell name to SrvVSchema for all cells,
	// optionally filtered by cell name.
	GetSrvVSchemas(context.Context, *connect_go.Request[vtctldata.GetSrvVSchemasRequest]) (*connect_go.Response[vtctldata.GetSrvVSchemasResponse], error)
	// GetTablet returns information about a tablet.
	GetTablet(context.Context, *connect_go.Request[vtctldata.GetTabletRequest]) (*connect_go.Response[vtctldata.GetTabletResponse], error)
	// GetTablets returns tablets, optionally filtered by keyspace and shard.
	GetTablets(context.Context, *connect_go.Request[vtctldata.GetTabletsRequest]) (*connect_go.Response[vtctldata.GetTabletsResponse], error)
	// GetVersion returns the version of a tablet from its debug vars.
	GetVersion(context.Context, *connect_go.Request[vtctldata.GetVersionRequest]) (*connect_go.Response[vtctldata.GetVersionResponse], error)
	// GetVSchema returns the vschema for a keyspace.
	GetVSchema(context.Context, *connect_go.Request[vtctldata.GetVSchemaRequest]) (*connect_go.Response[vtctldata.GetVSchemaResponse], error)
	// GetWorkflows returns a list of workflows for the given keyspace.
	GetWorkflows(context.Context, *connect_go.Request[vtctldata.GetWorkflowsRequest]) (*connect_go.Response[vtctldata.GetWorkflowsResponse], error)
	// InitShardPrimary sets the initial primary for a shard. Will make all other
	// tablets in the shard replicas of the provided primary.
	//
	// WARNING: This could cause data loss on an already replicating shard.
	// PlannedReparentShard or EmergencyReparentShard should be used in those
	// cases instead.
	InitShardPrimary(context.Context, *connect_go.Request[vtctldata.InitShardPrimaryRequest]) (*connect_go.Response[vtctldata.InitShardPrimaryResponse], error)
	// PingTablet checks that the specified tablet is awake and responding to RPCs.
	// This command can be blocked by other in-flight operations.
	PingTablet(context.Context, *connect_go.Request[vtctldata.PingTabletRequest]) (*connect_go.Response[vtctldata.PingTabletResponse], error)
	// PlannedReparentShard reparents the shard to the new primary, or away from
	// an old primary. Both the old and new primaries need to be reachable and
	// running.
	//
	// **NOTE**: The vtctld will not consider any replicas outside the cell the
	// current shard primary is in for promotion unless NewPrimary is explicitly
	// provided in the request.
	PlannedReparentShard(context.Context, *connect_go.Request[vtctldata.PlannedReparentShardRequest]) (*connect_go.Response[vtctldata.PlannedReparentShardResponse], error)
	// RebuildKeyspaceGraph rebuilds the serving data for a keyspace.
	//
	// This may trigger an update to all connected clients.
	RebuildKeyspaceGraph(context.Context, *connect_go.Request[vtctldata.RebuildKeyspaceGraphRequest]) (*connect_go.Response[vtctldata.RebuildKeyspaceGraphResponse], error)
	// RebuildVSchemaGraph rebuilds the per-cell SrvVSchema from the global
	// VSchema objects in the provided cells (or all cells in the topo none
	// provided).
	RebuildVSchemaGraph(context.Context, *connect_go.Request[vtctldata.RebuildVSchemaGraphRequest]) (*connect_go.Response[vtctldata.RebuildVSchemaGraphResponse], error)
	// RefreshState reloads the tablet record on the specified tablet.
	RefreshState(context.Context, *connect_go.Request[vtctldata.RefreshStateRequest]) (*connect_go.Response[vtctldata.RefreshStateResponse], error)
	// RefreshStateByShard calls RefreshState on all the tablets in the given shard.
	RefreshStateByShard(context.Context, *connect_go.Request[vtctldata.RefreshStateByShardRequest]) (*connect_go.Response[vtctldata.RefreshStateByShardResponse], error)
	// ReloadSchema instructs the remote tablet to reload its schema.
	ReloadSchema(context.Context, *connect_go.Request[vtctldata.ReloadSchemaRequest]) (*connect_go.Response[vtctldata.ReloadSchemaResponse], error)
	// ReloadSchemaKeyspace reloads the schema on all tablets in a keyspace.
	ReloadSchemaKeyspace(context.Context, *connect_go.Request[vtctldata.ReloadSchemaKeyspaceRequest]) (*connect_go.Response[vtctldata.ReloadSchemaKeyspaceResponse], error)
	// ReloadSchemaShard reloads the schema on all tablets in a shard.
	//
	// In general, we don't always expect all replicas to be ready to reload, and
	// the periodic schema reload makes them self-healing anyway. So, we do this
	// on a best-effort basis, and log warnings for any tablets that fail to
	// reload within the context deadline.
	ReloadSchemaShard(context.Context, *connect_go.Request[vtctldata.ReloadSchemaShardRequest]) (*connect_go.Response[vtctldata.ReloadSchemaShardResponse], error)
	// RemoveBackup removes a backup from the BackupStorage used by vtctld.
	RemoveBackup(context.Context, *connect_go.Request[vtctldata.RemoveBackupRequest]) (*connect_go.Response[vtctldata.RemoveBackupResponse], error)
	// RemoveKeyspaceCell removes the specified cell from the Cells list for all
	// shards in the specified keyspace (by calling RemoveShardCell on every
	// shard). It also removes the SrvKeyspace for that keyspace in that cell.
	RemoveKeyspaceCell(context.Context, *connect_go.Request[vtctldata.RemoveKeyspaceCellRequest]) (*connect_go.Response[vtctldata.RemoveKeyspaceCellResponse], error)
	// RemoveShardCell removes the specified cell from the specified shard's Cells
	// list.
	RemoveShardCell(context.Context, *connect_go.Request[vtctldata.RemoveShardCellRequest]) (*connect_go.Response[vtctldata.RemoveShardCellResponse], error)
	// ReparentTablet reparents a tablet to the current primary in the shard. This
	// only works if the current replica position matches the last known reparent
	// action.
	ReparentTablet(context.Context, *connect_go.Request[vtctldata.ReparentTabletRequest]) (*connect_go.Response[vtctldata.ReparentTabletResponse], error)
	// RestoreFromBackup stops mysqld for the given tablet and restores a backup.
	RestoreFromBackup(context.Context, *connect_go.Request[vtctldata.RestoreFromBackupRequest], *connect_go.ServerStream[vtctldata.RestoreFromBackupResponse]) error
	// RunHealthCheck runs a healthcheck on the remote tablet.
	RunHealthCheck(context.Context, *connect_go.Request[vtctldata.RunHealthCheckRequest]) (*connect_go.Response[vtctldata.RunHealthCheckResponse], error)
	// SetKeyspaceDurabilityPolicy updates the DurabilityPolicy for a keyspace.
	SetKeyspaceDurabilityPolicy(context.Context, *connect_go.Request[vtctldata.SetKeyspaceDurabilityPolicyRequest]) (*connect_go.Response[vtctldata.SetKeyspaceDurabilityPolicyResponse], error)
	// SetShardIsPrimaryServing adds or removes a shard from serving.
	//
	// This is meant as an emergency function. It does not rebuild any serving
	// graph (i.e. it does not run RebuildKeyspaceGraph).
	SetShardIsPrimaryServing(context.Context, *connect_go.Request[vtctldata.SetShardIsPrimaryServingRequest]) (*connect_go.Response[vtctldata.SetShardIsPrimaryServingResponse], error)
	// SetShardTabletControl updates the TabletControl topo record for a shard and
	// tablet type.
	//
	// This should only be used for an emergency fix, or after a finished
	// Reshard. See the documentation on SetShardTabletControlRequest for more
	// information about the different update modes.
	SetShardTabletControl(context.Context, *connect_go.Request[vtctldata.SetShardTabletControlRequest]) (*connect_go.Response[vtctldata.SetShardTabletControlResponse], error)
	// SetWritable sets a tablet as read-write (writable=true) or read-only (writable=false).
	SetWritable(context.Context, *connect_go.Request[vtctldata.SetWritableRequest]) (*connect_go.Response[vtctldata.SetWritableResponse], error)
	// ShardReplicationAdd adds an entry to a topodata.ShardReplication object.
	//
	// It is a low-level function and should generally not be called.
	ShardReplicationAdd(context.Context, *connect_go.Request[vtctldata.ShardReplicationAddRequest]) (*connect_go.Response[vtctldata.ShardReplicationAddResponse], error)
	// ShardReplicationFix walks the replication graph for a shard in a cell and
	// attempts to fix the first problem encountered, returning information about
	// the problem fixed, if any.
	ShardReplicationFix(context.Context, *connect_go.Request[vtctldata.ShardReplicationFixRequest]) (*connect_go.Response[vtctldata.ShardReplicationFixResponse], error)
	// ShardReplicationPositions returns the replication position of each tablet
	// in a shard. This RPC makes a best-effort to return partial results. For
	// example, if one tablet in the shard graph is unreachable, then
	// ShardReplicationPositions will return non-error, and include valid results
	// for the reachable tablets.
	ShardReplicationPositions(context.Context, *connect_go.Request[vtctldata.ShardReplicationPositionsRequest]) (*connect_go.Response[vtctldata.ShardReplicationPositionsResponse], error)
	// ShardReplicationRemove removes an entry from a topodata.ShardReplication
	// object.
	//
	// It is a low-level function and should generally not be called.
	ShardReplicationRemove(context.Context, *connect_go.Request[vtctldata.ShardReplicationRemoveRequest]) (*connect_go.Response[vtctldata.ShardReplicationRemoveResponse], error)
	// SleepTablet blocks the aciton queue on the specified tablet for the
	// specified duration.
	//
	// This is typically used for testing.
	SleepTablet(context.Context, *connect_go.Request[vtctldata.SleepTabletRequest]) (*connect_go.Response[vtctldata.SleepTabletResponse], error)
	// SourceShardAdd adds the SourceShard record with the provided index. This
	// should be used only as an emergency function.
	//
	// It does not call RefreshState for the shard primary.
	SourceShardAdd(context.Context, *connect_go.Request[vtctldata.SourceShardAddRequest]) (*connect_go.Response[vtctldata.SourceShardAddResponse], error)
	// SourceShardDelete deletes the SourceShard record with the provided index.
	// This should be used only as an emergency cleanup function.
	//
	// It does not call RefreshState for the shard primary.
	SourceShardDelete(context.Context, *connect_go.Request[vtctldata.SourceShardDeleteRequest]) (*connect_go.Response[vtctldata.SourceShardDeleteResponse], error)
	// StartReplication starts replication on the specified tablet.
	StartReplication(context.Context, *connect_go.Request[vtctldata.StartReplicationRequest]) (*connect_go.Response[vtctldata.StartReplicationResponse], error)
	// StopReplication stops replication on the specified tablet.
	StopReplication(context.Context, *connect_go.Request[vtctldata.StopReplicationRequest]) (*connect_go.Response[vtctldata.StopReplicationResponse], error)
	// TabletExternallyReparented changes metadata in the topology server to
	// acknowledge a shard primary change performed by an external tool (e.g.
	// orchestrator).
	//
	// See the Reparenting guide for more information:
	// https://vitess.io/docs/user-guides/configuration-advanced/reparenting/#external-reparenting.
	TabletExternallyReparented(context.Context, *connect_go.Request[vtctldata.TabletExternallyReparentedRequest]) (*connect_go.Response[vtctldata.TabletExternallyReparentedResponse], error)
	// UpdateCellInfo updates the content of a CellInfo with the provided
	// parameters. Empty values are ignored. If the cell does not exist, the
	// CellInfo will be created.
	UpdateCellInfo(context.Context, *connect_go.Request[vtctldata.UpdateCellInfoRequest]) (*connect_go.Response[vtctldata.UpdateCellInfoResponse], error)
	// UpdateCellsAlias updates the content of a CellsAlias with the provided
	// parameters. Empty values are ignored. If the alias does not exist, the
	// CellsAlias will be created.
	UpdateCellsAlias(context.Context, *connect_go.Request[vtctldata.UpdateCellsAliasRequest]) (*connect_go.Response[vtctldata.UpdateCellsAliasResponse], error)
	// Validate validates that all nodes from the global replication graph are
	// reachable, and that all tablets in discoverable cells are consistent.
	Validate(context.Context, *connect_go.Request[vtctldata.ValidateRequest]) (*connect_go.Response[vtctldata.ValidateResponse], error)
	// ValidateKeyspace validates that all nodes reachable from the specified
	// keyspace are consistent.
	ValidateKeyspace(context.Context, *connect_go.Request[vtctldata.ValidateKeyspaceRequest]) (*connect_go.Response[vtctldata.ValidateKeyspaceResponse], error)
	// ValidateSchemaKeyspace validates that the schema on the primary tablet for shard 0 matches the schema on all of the other tablets in the keyspace.
	ValidateSchemaKeyspace(context.Context, *connect_go.Request[vtctldata.ValidateSchemaKeyspaceRequest]) (*connect_go.Response[vtctldata.ValidateSchemaKeyspaceResponse], error)
	// ValidateShard validates that all nodes reachable from the specified shard
	// are consistent.
	ValidateShard(context.Context, *connect_go.Request[vtctldata.ValidateShardRequest]) (*connect_go.Response[vtctldata.ValidateShardResponse], error)
	// ValidateVersionKeyspace validates that the version on the primary of shard 0 matches all of the other tablets in the keyspace.
	ValidateVersionKeyspace(context.Context, *connect_go.Request[vtctldata.ValidateVersionKeyspaceRequest]) (*connect_go.Response[vtctldata.ValidateVersionKeyspaceResponse], error)
	// ValidateVSchema compares the schema of each primary tablet in "keyspace/shards..." to the vschema and errs if there are differences.
	ValidateVSchema(context.Context, *connect_go.Request[vtctldata.ValidateVSchemaRequest]) (*connect_go.Response[vtctldata.ValidateVSchemaResponse], error)
}

// NewVtctldHandler builds an HTTP handler from the service implementation. It returns the path on
// which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewVtctldHandler(svc VtctldHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/vtctlservice.Vtctld/AddCellInfo", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/AddCellInfo",
		svc.AddCellInfo,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/AddCellsAlias", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/AddCellsAlias",
		svc.AddCellsAlias,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ApplyRoutingRules", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ApplyRoutingRules",
		svc.ApplyRoutingRules,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ApplySchema", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ApplySchema",
		svc.ApplySchema,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ApplyShardRoutingRules", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ApplyShardRoutingRules",
		svc.ApplyShardRoutingRules,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ApplyVSchema", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ApplyVSchema",
		svc.ApplyVSchema,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/Backup", connect_go.NewServerStreamHandler(
		"/vtctlservice.Vtctld/Backup",
		svc.Backup,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/BackupShard", connect_go.NewServerStreamHandler(
		"/vtctlservice.Vtctld/BackupShard",
		svc.BackupShard,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ChangeTabletType", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ChangeTabletType",
		svc.ChangeTabletType,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/CreateKeyspace", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/CreateKeyspace",
		svc.CreateKeyspace,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/CreateShard", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/CreateShard",
		svc.CreateShard,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/DeleteCellInfo", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/DeleteCellInfo",
		svc.DeleteCellInfo,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/DeleteCellsAlias", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/DeleteCellsAlias",
		svc.DeleteCellsAlias,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/DeleteKeyspace", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/DeleteKeyspace",
		svc.DeleteKeyspace,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/DeleteShards", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/DeleteShards",
		svc.DeleteShards,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/DeleteSrvVSchema", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/DeleteSrvVSchema",
		svc.DeleteSrvVSchema,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/DeleteTablets", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/DeleteTablets",
		svc.DeleteTablets,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/EmergencyReparentShard", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/EmergencyReparentShard",
		svc.EmergencyReparentShard,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ExecuteFetchAsApp", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ExecuteFetchAsApp",
		svc.ExecuteFetchAsApp,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ExecuteFetchAsDBA", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ExecuteFetchAsDBA",
		svc.ExecuteFetchAsDBA,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ExecuteHook", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ExecuteHook",
		svc.ExecuteHook,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/FindAllShardsInKeyspace", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/FindAllShardsInKeyspace",
		svc.FindAllShardsInKeyspace,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetBackups", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetBackups",
		svc.GetBackups,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetCellInfo", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetCellInfo",
		svc.GetCellInfo,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetCellInfoNames", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetCellInfoNames",
		svc.GetCellInfoNames,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetCellsAliases", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetCellsAliases",
		svc.GetCellsAliases,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetFullStatus", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetFullStatus",
		svc.GetFullStatus,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetKeyspace", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetKeyspace",
		svc.GetKeyspace,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetKeyspaces", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetKeyspaces",
		svc.GetKeyspaces,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetPermissions", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetPermissions",
		svc.GetPermissions,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetRoutingRules", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetRoutingRules",
		svc.GetRoutingRules,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetSchema", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetSchema",
		svc.GetSchema,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetShard", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetShard",
		svc.GetShard,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetShardRoutingRules", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetShardRoutingRules",
		svc.GetShardRoutingRules,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetSrvKeyspaceNames", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetSrvKeyspaceNames",
		svc.GetSrvKeyspaceNames,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetSrvKeyspaces", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetSrvKeyspaces",
		svc.GetSrvKeyspaces,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetSrvVSchema", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetSrvVSchema",
		svc.GetSrvVSchema,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetSrvVSchemas", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetSrvVSchemas",
		svc.GetSrvVSchemas,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetTablet", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetTablet",
		svc.GetTablet,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetTablets", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetTablets",
		svc.GetTablets,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetVersion", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetVersion",
		svc.GetVersion,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetVSchema", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetVSchema",
		svc.GetVSchema,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/GetWorkflows", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/GetWorkflows",
		svc.GetWorkflows,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/InitShardPrimary", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/InitShardPrimary",
		svc.InitShardPrimary,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/PingTablet", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/PingTablet",
		svc.PingTablet,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/PlannedReparentShard", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/PlannedReparentShard",
		svc.PlannedReparentShard,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/RebuildKeyspaceGraph", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/RebuildKeyspaceGraph",
		svc.RebuildKeyspaceGraph,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/RebuildVSchemaGraph", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/RebuildVSchemaGraph",
		svc.RebuildVSchemaGraph,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/RefreshState", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/RefreshState",
		svc.RefreshState,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/RefreshStateByShard", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/RefreshStateByShard",
		svc.RefreshStateByShard,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ReloadSchema", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ReloadSchema",
		svc.ReloadSchema,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ReloadSchemaKeyspace", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ReloadSchemaKeyspace",
		svc.ReloadSchemaKeyspace,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ReloadSchemaShard", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ReloadSchemaShard",
		svc.ReloadSchemaShard,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/RemoveBackup", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/RemoveBackup",
		svc.RemoveBackup,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/RemoveKeyspaceCell", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/RemoveKeyspaceCell",
		svc.RemoveKeyspaceCell,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/RemoveShardCell", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/RemoveShardCell",
		svc.RemoveShardCell,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ReparentTablet", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ReparentTablet",
		svc.ReparentTablet,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/RestoreFromBackup", connect_go.NewServerStreamHandler(
		"/vtctlservice.Vtctld/RestoreFromBackup",
		svc.RestoreFromBackup,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/RunHealthCheck", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/RunHealthCheck",
		svc.RunHealthCheck,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/SetKeyspaceDurabilityPolicy", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/SetKeyspaceDurabilityPolicy",
		svc.SetKeyspaceDurabilityPolicy,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/SetShardIsPrimaryServing", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/SetShardIsPrimaryServing",
		svc.SetShardIsPrimaryServing,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/SetShardTabletControl", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/SetShardTabletControl",
		svc.SetShardTabletControl,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/SetWritable", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/SetWritable",
		svc.SetWritable,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ShardReplicationAdd", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ShardReplicationAdd",
		svc.ShardReplicationAdd,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ShardReplicationFix", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ShardReplicationFix",
		svc.ShardReplicationFix,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ShardReplicationPositions", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ShardReplicationPositions",
		svc.ShardReplicationPositions,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ShardReplicationRemove", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ShardReplicationRemove",
		svc.ShardReplicationRemove,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/SleepTablet", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/SleepTablet",
		svc.SleepTablet,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/SourceShardAdd", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/SourceShardAdd",
		svc.SourceShardAdd,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/SourceShardDelete", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/SourceShardDelete",
		svc.SourceShardDelete,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/StartReplication", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/StartReplication",
		svc.StartReplication,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/StopReplication", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/StopReplication",
		svc.StopReplication,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/TabletExternallyReparented", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/TabletExternallyReparented",
		svc.TabletExternallyReparented,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/UpdateCellInfo", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/UpdateCellInfo",
		svc.UpdateCellInfo,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/UpdateCellsAlias", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/UpdateCellsAlias",
		svc.UpdateCellsAlias,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/Validate", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/Validate",
		svc.Validate,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ValidateKeyspace", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ValidateKeyspace",
		svc.ValidateKeyspace,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ValidateSchemaKeyspace", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ValidateSchemaKeyspace",
		svc.ValidateSchemaKeyspace,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ValidateShard", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ValidateShard",
		svc.ValidateShard,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ValidateVersionKeyspace", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ValidateVersionKeyspace",
		svc.ValidateVersionKeyspace,
		opts...,
	))
	mux.Handle("/vtctlservice.Vtctld/ValidateVSchema", connect_go.NewUnaryHandler(
		"/vtctlservice.Vtctld/ValidateVSchema",
		svc.ValidateVSchema,
		opts...,
	))
	return "/vtctlservice.Vtctld/", mux
}

// UnimplementedVtctldHandler returns CodeUnimplemented from all methods.
type UnimplementedVtctldHandler struct{}

func (UnimplementedVtctldHandler) AddCellInfo(context.Context, *connect_go.Request[vtctldata.AddCellInfoRequest]) (*connect_go.Response[vtctldata.AddCellInfoResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.AddCellInfo is not implemented"))
}

func (UnimplementedVtctldHandler) AddCellsAlias(context.Context, *connect_go.Request[vtctldata.AddCellsAliasRequest]) (*connect_go.Response[vtctldata.AddCellsAliasResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.AddCellsAlias is not implemented"))
}

func (UnimplementedVtctldHandler) ApplyRoutingRules(context.Context, *connect_go.Request[vtctldata.ApplyRoutingRulesRequest]) (*connect_go.Response[vtctldata.ApplyRoutingRulesResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ApplyRoutingRules is not implemented"))
}

func (UnimplementedVtctldHandler) ApplySchema(context.Context, *connect_go.Request[vtctldata.ApplySchemaRequest]) (*connect_go.Response[vtctldata.ApplySchemaResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ApplySchema is not implemented"))
}

func (UnimplementedVtctldHandler) ApplyShardRoutingRules(context.Context, *connect_go.Request[vtctldata.ApplyShardRoutingRulesRequest]) (*connect_go.Response[vtctldata.ApplyShardRoutingRulesResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ApplyShardRoutingRules is not implemented"))
}

func (UnimplementedVtctldHandler) ApplyVSchema(context.Context, *connect_go.Request[vtctldata.ApplyVSchemaRequest]) (*connect_go.Response[vtctldata.ApplyVSchemaResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ApplyVSchema is not implemented"))
}

func (UnimplementedVtctldHandler) Backup(context.Context, *connect_go.Request[vtctldata.BackupRequest], *connect_go.ServerStream[vtctldata.BackupResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.Backup is not implemented"))
}

func (UnimplementedVtctldHandler) BackupShard(context.Context, *connect_go.Request[vtctldata.BackupShardRequest], *connect_go.ServerStream[vtctldata.BackupResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.BackupShard is not implemented"))
}

func (UnimplementedVtctldHandler) ChangeTabletType(context.Context, *connect_go.Request[vtctldata.ChangeTabletTypeRequest]) (*connect_go.Response[vtctldata.ChangeTabletTypeResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ChangeTabletType is not implemented"))
}

func (UnimplementedVtctldHandler) CreateKeyspace(context.Context, *connect_go.Request[vtctldata.CreateKeyspaceRequest]) (*connect_go.Response[vtctldata.CreateKeyspaceResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.CreateKeyspace is not implemented"))
}

func (UnimplementedVtctldHandler) CreateShard(context.Context, *connect_go.Request[vtctldata.CreateShardRequest]) (*connect_go.Response[vtctldata.CreateShardResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.CreateShard is not implemented"))
}

func (UnimplementedVtctldHandler) DeleteCellInfo(context.Context, *connect_go.Request[vtctldata.DeleteCellInfoRequest]) (*connect_go.Response[vtctldata.DeleteCellInfoResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.DeleteCellInfo is not implemented"))
}

func (UnimplementedVtctldHandler) DeleteCellsAlias(context.Context, *connect_go.Request[vtctldata.DeleteCellsAliasRequest]) (*connect_go.Response[vtctldata.DeleteCellsAliasResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.DeleteCellsAlias is not implemented"))
}

func (UnimplementedVtctldHandler) DeleteKeyspace(context.Context, *connect_go.Request[vtctldata.DeleteKeyspaceRequest]) (*connect_go.Response[vtctldata.DeleteKeyspaceResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.DeleteKeyspace is not implemented"))
}

func (UnimplementedVtctldHandler) DeleteShards(context.Context, *connect_go.Request[vtctldata.DeleteShardsRequest]) (*connect_go.Response[vtctldata.DeleteShardsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.DeleteShards is not implemented"))
}

func (UnimplementedVtctldHandler) DeleteSrvVSchema(context.Context, *connect_go.Request[vtctldata.DeleteSrvVSchemaRequest]) (*connect_go.Response[vtctldata.DeleteSrvVSchemaResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.DeleteSrvVSchema is not implemented"))
}

func (UnimplementedVtctldHandler) DeleteTablets(context.Context, *connect_go.Request[vtctldata.DeleteTabletsRequest]) (*connect_go.Response[vtctldata.DeleteTabletsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.DeleteTablets is not implemented"))
}

func (UnimplementedVtctldHandler) EmergencyReparentShard(context.Context, *connect_go.Request[vtctldata.EmergencyReparentShardRequest]) (*connect_go.Response[vtctldata.EmergencyReparentShardResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.EmergencyReparentShard is not implemented"))
}

func (UnimplementedVtctldHandler) ExecuteFetchAsApp(context.Context, *connect_go.Request[vtctldata.ExecuteFetchAsAppRequest]) (*connect_go.Response[vtctldata.ExecuteFetchAsAppResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ExecuteFetchAsApp is not implemented"))
}

func (UnimplementedVtctldHandler) ExecuteFetchAsDBA(context.Context, *connect_go.Request[vtctldata.ExecuteFetchAsDBARequest]) (*connect_go.Response[vtctldata.ExecuteFetchAsDBAResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ExecuteFetchAsDBA is not implemented"))
}

func (UnimplementedVtctldHandler) ExecuteHook(context.Context, *connect_go.Request[vtctldata.ExecuteHookRequest]) (*connect_go.Response[vtctldata.ExecuteHookResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ExecuteHook is not implemented"))
}

func (UnimplementedVtctldHandler) FindAllShardsInKeyspace(context.Context, *connect_go.Request[vtctldata.FindAllShardsInKeyspaceRequest]) (*connect_go.Response[vtctldata.FindAllShardsInKeyspaceResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.FindAllShardsInKeyspace is not implemented"))
}

func (UnimplementedVtctldHandler) GetBackups(context.Context, *connect_go.Request[vtctldata.GetBackupsRequest]) (*connect_go.Response[vtctldata.GetBackupsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetBackups is not implemented"))
}

func (UnimplementedVtctldHandler) GetCellInfo(context.Context, *connect_go.Request[vtctldata.GetCellInfoRequest]) (*connect_go.Response[vtctldata.GetCellInfoResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetCellInfo is not implemented"))
}

func (UnimplementedVtctldHandler) GetCellInfoNames(context.Context, *connect_go.Request[vtctldata.GetCellInfoNamesRequest]) (*connect_go.Response[vtctldata.GetCellInfoNamesResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetCellInfoNames is not implemented"))
}

func (UnimplementedVtctldHandler) GetCellsAliases(context.Context, *connect_go.Request[vtctldata.GetCellsAliasesRequest]) (*connect_go.Response[vtctldata.GetCellsAliasesResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetCellsAliases is not implemented"))
}

func (UnimplementedVtctldHandler) GetFullStatus(context.Context, *connect_go.Request[vtctldata.GetFullStatusRequest]) (*connect_go.Response[vtctldata.GetFullStatusResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetFullStatus is not implemented"))
}

func (UnimplementedVtctldHandler) GetKeyspace(context.Context, *connect_go.Request[vtctldata.GetKeyspaceRequest]) (*connect_go.Response[vtctldata.GetKeyspaceResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetKeyspace is not implemented"))
}

func (UnimplementedVtctldHandler) GetKeyspaces(context.Context, *connect_go.Request[vtctldata.GetKeyspacesRequest]) (*connect_go.Response[vtctldata.GetKeyspacesResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetKeyspaces is not implemented"))
}

func (UnimplementedVtctldHandler) GetPermissions(context.Context, *connect_go.Request[vtctldata.GetPermissionsRequest]) (*connect_go.Response[vtctldata.GetPermissionsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetPermissions is not implemented"))
}

func (UnimplementedVtctldHandler) GetRoutingRules(context.Context, *connect_go.Request[vtctldata.GetRoutingRulesRequest]) (*connect_go.Response[vtctldata.GetRoutingRulesResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetRoutingRules is not implemented"))
}

func (UnimplementedVtctldHandler) GetSchema(context.Context, *connect_go.Request[vtctldata.GetSchemaRequest]) (*connect_go.Response[vtctldata.GetSchemaResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetSchema is not implemented"))
}

func (UnimplementedVtctldHandler) GetShard(context.Context, *connect_go.Request[vtctldata.GetShardRequest]) (*connect_go.Response[vtctldata.GetShardResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetShard is not implemented"))
}

func (UnimplementedVtctldHandler) GetShardRoutingRules(context.Context, *connect_go.Request[vtctldata.GetShardRoutingRulesRequest]) (*connect_go.Response[vtctldata.GetShardRoutingRulesResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetShardRoutingRules is not implemented"))
}

func (UnimplementedVtctldHandler) GetSrvKeyspaceNames(context.Context, *connect_go.Request[vtctldata.GetSrvKeyspaceNamesRequest]) (*connect_go.Response[vtctldata.GetSrvKeyspaceNamesResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetSrvKeyspaceNames is not implemented"))
}

func (UnimplementedVtctldHandler) GetSrvKeyspaces(context.Context, *connect_go.Request[vtctldata.GetSrvKeyspacesRequest]) (*connect_go.Response[vtctldata.GetSrvKeyspacesResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetSrvKeyspaces is not implemented"))
}

func (UnimplementedVtctldHandler) GetSrvVSchema(context.Context, *connect_go.Request[vtctldata.GetSrvVSchemaRequest]) (*connect_go.Response[vtctldata.GetSrvVSchemaResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetSrvVSchema is not implemented"))
}

func (UnimplementedVtctldHandler) GetSrvVSchemas(context.Context, *connect_go.Request[vtctldata.GetSrvVSchemasRequest]) (*connect_go.Response[vtctldata.GetSrvVSchemasResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetSrvVSchemas is not implemented"))
}

func (UnimplementedVtctldHandler) GetTablet(context.Context, *connect_go.Request[vtctldata.GetTabletRequest]) (*connect_go.Response[vtctldata.GetTabletResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetTablet is not implemented"))
}

func (UnimplementedVtctldHandler) GetTablets(context.Context, *connect_go.Request[vtctldata.GetTabletsRequest]) (*connect_go.Response[vtctldata.GetTabletsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetTablets is not implemented"))
}

func (UnimplementedVtctldHandler) GetVersion(context.Context, *connect_go.Request[vtctldata.GetVersionRequest]) (*connect_go.Response[vtctldata.GetVersionResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetVersion is not implemented"))
}

func (UnimplementedVtctldHandler) GetVSchema(context.Context, *connect_go.Request[vtctldata.GetVSchemaRequest]) (*connect_go.Response[vtctldata.GetVSchemaResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetVSchema is not implemented"))
}

func (UnimplementedVtctldHandler) GetWorkflows(context.Context, *connect_go.Request[vtctldata.GetWorkflowsRequest]) (*connect_go.Response[vtctldata.GetWorkflowsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.GetWorkflows is not implemented"))
}

func (UnimplementedVtctldHandler) InitShardPrimary(context.Context, *connect_go.Request[vtctldata.InitShardPrimaryRequest]) (*connect_go.Response[vtctldata.InitShardPrimaryResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.InitShardPrimary is not implemented"))
}

func (UnimplementedVtctldHandler) PingTablet(context.Context, *connect_go.Request[vtctldata.PingTabletRequest]) (*connect_go.Response[vtctldata.PingTabletResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.PingTablet is not implemented"))
}

func (UnimplementedVtctldHandler) PlannedReparentShard(context.Context, *connect_go.Request[vtctldata.PlannedReparentShardRequest]) (*connect_go.Response[vtctldata.PlannedReparentShardResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.PlannedReparentShard is not implemented"))
}

func (UnimplementedVtctldHandler) RebuildKeyspaceGraph(context.Context, *connect_go.Request[vtctldata.RebuildKeyspaceGraphRequest]) (*connect_go.Response[vtctldata.RebuildKeyspaceGraphResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.RebuildKeyspaceGraph is not implemented"))
}

func (UnimplementedVtctldHandler) RebuildVSchemaGraph(context.Context, *connect_go.Request[vtctldata.RebuildVSchemaGraphRequest]) (*connect_go.Response[vtctldata.RebuildVSchemaGraphResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.RebuildVSchemaGraph is not implemented"))
}

func (UnimplementedVtctldHandler) RefreshState(context.Context, *connect_go.Request[vtctldata.RefreshStateRequest]) (*connect_go.Response[vtctldata.RefreshStateResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.RefreshState is not implemented"))
}

func (UnimplementedVtctldHandler) RefreshStateByShard(context.Context, *connect_go.Request[vtctldata.RefreshStateByShardRequest]) (*connect_go.Response[vtctldata.RefreshStateByShardResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.RefreshStateByShard is not implemented"))
}

func (UnimplementedVtctldHandler) ReloadSchema(context.Context, *connect_go.Request[vtctldata.ReloadSchemaRequest]) (*connect_go.Response[vtctldata.ReloadSchemaResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ReloadSchema is not implemented"))
}

func (UnimplementedVtctldHandler) ReloadSchemaKeyspace(context.Context, *connect_go.Request[vtctldata.ReloadSchemaKeyspaceRequest]) (*connect_go.Response[vtctldata.ReloadSchemaKeyspaceResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ReloadSchemaKeyspace is not implemented"))
}

func (UnimplementedVtctldHandler) ReloadSchemaShard(context.Context, *connect_go.Request[vtctldata.ReloadSchemaShardRequest]) (*connect_go.Response[vtctldata.ReloadSchemaShardResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ReloadSchemaShard is not implemented"))
}

func (UnimplementedVtctldHandler) RemoveBackup(context.Context, *connect_go.Request[vtctldata.RemoveBackupRequest]) (*connect_go.Response[vtctldata.RemoveBackupResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.RemoveBackup is not implemented"))
}

func (UnimplementedVtctldHandler) RemoveKeyspaceCell(context.Context, *connect_go.Request[vtctldata.RemoveKeyspaceCellRequest]) (*connect_go.Response[vtctldata.RemoveKeyspaceCellResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.RemoveKeyspaceCell is not implemented"))
}

func (UnimplementedVtctldHandler) RemoveShardCell(context.Context, *connect_go.Request[vtctldata.RemoveShardCellRequest]) (*connect_go.Response[vtctldata.RemoveShardCellResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.RemoveShardCell is not implemented"))
}

func (UnimplementedVtctldHandler) ReparentTablet(context.Context, *connect_go.Request[vtctldata.ReparentTabletRequest]) (*connect_go.Response[vtctldata.ReparentTabletResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ReparentTablet is not implemented"))
}

func (UnimplementedVtctldHandler) RestoreFromBackup(context.Context, *connect_go.Request[vtctldata.RestoreFromBackupRequest], *connect_go.ServerStream[vtctldata.RestoreFromBackupResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.RestoreFromBackup is not implemented"))
}

func (UnimplementedVtctldHandler) RunHealthCheck(context.Context, *connect_go.Request[vtctldata.RunHealthCheckRequest]) (*connect_go.Response[vtctldata.RunHealthCheckResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.RunHealthCheck is not implemented"))
}

func (UnimplementedVtctldHandler) SetKeyspaceDurabilityPolicy(context.Context, *connect_go.Request[vtctldata.SetKeyspaceDurabilityPolicyRequest]) (*connect_go.Response[vtctldata.SetKeyspaceDurabilityPolicyResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.SetKeyspaceDurabilityPolicy is not implemented"))
}

func (UnimplementedVtctldHandler) SetShardIsPrimaryServing(context.Context, *connect_go.Request[vtctldata.SetShardIsPrimaryServingRequest]) (*connect_go.Response[vtctldata.SetShardIsPrimaryServingResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.SetShardIsPrimaryServing is not implemented"))
}

func (UnimplementedVtctldHandler) SetShardTabletControl(context.Context, *connect_go.Request[vtctldata.SetShardTabletControlRequest]) (*connect_go.Response[vtctldata.SetShardTabletControlResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.SetShardTabletControl is not implemented"))
}

func (UnimplementedVtctldHandler) SetWritable(context.Context, *connect_go.Request[vtctldata.SetWritableRequest]) (*connect_go.Response[vtctldata.SetWritableResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.SetWritable is not implemented"))
}

func (UnimplementedVtctldHandler) ShardReplicationAdd(context.Context, *connect_go.Request[vtctldata.ShardReplicationAddRequest]) (*connect_go.Response[vtctldata.ShardReplicationAddResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ShardReplicationAdd is not implemented"))
}

func (UnimplementedVtctldHandler) ShardReplicationFix(context.Context, *connect_go.Request[vtctldata.ShardReplicationFixRequest]) (*connect_go.Response[vtctldata.ShardReplicationFixResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ShardReplicationFix is not implemented"))
}

func (UnimplementedVtctldHandler) ShardReplicationPositions(context.Context, *connect_go.Request[vtctldata.ShardReplicationPositionsRequest]) (*connect_go.Response[vtctldata.ShardReplicationPositionsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ShardReplicationPositions is not implemented"))
}

func (UnimplementedVtctldHandler) ShardReplicationRemove(context.Context, *connect_go.Request[vtctldata.ShardReplicationRemoveRequest]) (*connect_go.Response[vtctldata.ShardReplicationRemoveResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ShardReplicationRemove is not implemented"))
}

func (UnimplementedVtctldHandler) SleepTablet(context.Context, *connect_go.Request[vtctldata.SleepTabletRequest]) (*connect_go.Response[vtctldata.SleepTabletResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.SleepTablet is not implemented"))
}

func (UnimplementedVtctldHandler) SourceShardAdd(context.Context, *connect_go.Request[vtctldata.SourceShardAddRequest]) (*connect_go.Response[vtctldata.SourceShardAddResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.SourceShardAdd is not implemented"))
}

func (UnimplementedVtctldHandler) SourceShardDelete(context.Context, *connect_go.Request[vtctldata.SourceShardDeleteRequest]) (*connect_go.Response[vtctldata.SourceShardDeleteResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.SourceShardDelete is not implemented"))
}

func (UnimplementedVtctldHandler) StartReplication(context.Context, *connect_go.Request[vtctldata.StartReplicationRequest]) (*connect_go.Response[vtctldata.StartReplicationResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.StartReplication is not implemented"))
}

func (UnimplementedVtctldHandler) StopReplication(context.Context, *connect_go.Request[vtctldata.StopReplicationRequest]) (*connect_go.Response[vtctldata.StopReplicationResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.StopReplication is not implemented"))
}

func (UnimplementedVtctldHandler) TabletExternallyReparented(context.Context, *connect_go.Request[vtctldata.TabletExternallyReparentedRequest]) (*connect_go.Response[vtctldata.TabletExternallyReparentedResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.TabletExternallyReparented is not implemented"))
}

func (UnimplementedVtctldHandler) UpdateCellInfo(context.Context, *connect_go.Request[vtctldata.UpdateCellInfoRequest]) (*connect_go.Response[vtctldata.UpdateCellInfoResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.UpdateCellInfo is not implemented"))
}

func (UnimplementedVtctldHandler) UpdateCellsAlias(context.Context, *connect_go.Request[vtctldata.UpdateCellsAliasRequest]) (*connect_go.Response[vtctldata.UpdateCellsAliasResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.UpdateCellsAlias is not implemented"))
}

func (UnimplementedVtctldHandler) Validate(context.Context, *connect_go.Request[vtctldata.ValidateRequest]) (*connect_go.Response[vtctldata.ValidateResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.Validate is not implemented"))
}

func (UnimplementedVtctldHandler) ValidateKeyspace(context.Context, *connect_go.Request[vtctldata.ValidateKeyspaceRequest]) (*connect_go.Response[vtctldata.ValidateKeyspaceResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ValidateKeyspace is not implemented"))
}

func (UnimplementedVtctldHandler) ValidateSchemaKeyspace(context.Context, *connect_go.Request[vtctldata.ValidateSchemaKeyspaceRequest]) (*connect_go.Response[vtctldata.ValidateSchemaKeyspaceResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ValidateSchemaKeyspace is not implemented"))
}

func (UnimplementedVtctldHandler) ValidateShard(context.Context, *connect_go.Request[vtctldata.ValidateShardRequest]) (*connect_go.Response[vtctldata.ValidateShardResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ValidateShard is not implemented"))
}

func (UnimplementedVtctldHandler) ValidateVersionKeyspace(context.Context, *connect_go.Request[vtctldata.ValidateVersionKeyspaceRequest]) (*connect_go.Response[vtctldata.ValidateVersionKeyspaceResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ValidateVersionKeyspace is not implemented"))
}

func (UnimplementedVtctldHandler) ValidateVSchema(context.Context, *connect_go.Request[vtctldata.ValidateVSchemaRequest]) (*connect_go.Response[vtctldata.ValidateVSchemaResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("vtctlservice.Vtctld.ValidateVSchema is not implemented"))
}
